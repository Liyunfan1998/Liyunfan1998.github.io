<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Yunfan Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>page - Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 4.2.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/archives">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Hexo</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/30/%E8%B4%B9%E9%9B%AA%E4%BF%A1%E6%81%AF%E7%9F%A9%E9%98%B5/">
                费雪信息矩阵
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-30</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>费雪信息矩阵是用来度量随机变量X所含有的关于自身随机分布函数位置参数$\theta$ 的信息量，最大似然估计中有着重要的度量价值</p>
<p>费雪信息矩阵体现了最大似然估计的参数方差，可以体现似然方法的准确程度，在统计学中有重要的地位，并且在经济学、医学等的相关统计领域应用广泛</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个i.i.d.的数据组$X_1,X_2,…,X_n$存在概率密度函数且服从一个概率分布$f(X,\theta)$, $\theta$ 为描述此分布的参数，利用最大似然估计法，当$X_i$已知，但$\theta$未知，得到使得发生所有$X_i$对应的最可能的 $\theta$值<br>$$<br>L(\textbf{X})=\prod_{i=1}^nf(X_i;\theta)\<br>\hat{\theta}=argmax_{\theta}L(\textbf{X})<br>$$<br>此时 $\theta$ 的估计值 $\hat{\theta}$ 就是使得 $L(\textbf{X})$ 取得最大值的值</p>
<p>对 $L(X)$ 先取对数，再求一阶偏导，得到其一阶偏导数的矩阵，记为$S(\textbf{X};\theta)$ 。事实上，使得$S=0$ 的 $\theta$ 的值代表了MLE的估计值<br>$$<br>S(\textbf{X}; \theta)=\sum_{i=1}^n\frac{\part \log f(X_i;\theta)}{\partial \theta}<br>$$<br>$S$ 维度为$n\times 1$, $n$ 为 $\theta$ 的维度 $(S$ 之后会用得到$)$ </p>
<p>那我们定义费雪信息矩阵 $I(\theta)$ 为 $S(I,\theta)$ 的二阶中心矩,同时又等于为$L(\textbf{X};\theta)$二阶偏导的期望矩阵<br>$$<br>I(\theta)=E[S(\textbf{X};\theta)^2|\theta]<br>=E[\frac{\part \log L(\textbf{X};\theta)}{\partial\theta}\frac{\part \log L(\textbf{X};\theta)}{\partial\theta^T}|\theta]<br>=-E[\frac{\part ^2\log L(\textbf{X};\theta)}{\partial\theta\partial\theta^T}|\theta]<br>$$<br>（第二个等号的证明用到第一个性质$E[S(\textbf{X};\theta)]=0,$ 可自行验证）</p>
<h4 id="举例正态分布"><a href="#举例正态分布" class="headerlink" title="举例正态分布"></a>举例正态分布</h4><p>对于满足正态分布的$n$个 i.i.d. 随机变量<br>$$<br>\log L(\mu,\sigma^2)=-\frac{n}{2}\log (\sigma^2)-\frac{n}{2}\log (2\pi)-\frac{1}{2\sigma^2}\sum_{i=1}^n(X_i-\mu)^2<br>$$<br>不论直接计算二阶偏导的期望矩阵还是计算一阶偏导生成矩阵的期望，都可以得到<br>$$<br>I(\mu,\sigma^2)=\left\lbrack \begin{array}{cc}<br>\frac{n}{\sigma^2 } &amp; 0\<br>0 &amp; \frac{n}{2\sigma^4 }<br>\end{array}\right\rbrack<br>$$</p>
<h4 id="性质以及用途"><a href="#性质以及用途" class="headerlink" title="性质以及用途"></a>性质以及用途</h4><p>在一般情形下<br>$$<br>E[S(\textbf{X};\theta)|\theta]=E[\frac{\part }{\part\theta}\log f(\textbf{X};\theta)|\theta]=\int\frac{\frac{\part}{\part\theta } f(x;\theta)}{f(x;\theta)}f(x;\theta)dx=\frac{\part}{\part\theta}\int f(x;\theta)dx=\frac{\part}{\part\theta}1=0<br>$$<br>因此添加上该零项之后：<br>$$<br>I(\theta)=E[S(\textbf{X};\theta)^2|\theta]-E[S(\textbf{X};\theta)|\theta]^2=Var[S(\textbf{X};\theta)|\theta]<br>$$<br>从而费雪信息矩阵在直观上代表了MLE方程的方差，在一定程度上会与解得的$\hat{\theta}$的方差有关。</p>
<p>下面不予以详细说明。代表方差的性质可以用来估计在某一分布下，不同的 $\textbf{X}$  所得到 $\theta$ 的方差。</p>
<p>事实上，所解得到的 $\hat{\theta}$ 满足如下分布：<br>$$<br>\sqrt{nI(\theta_0)}(\hat{\theta}-\theta_0)\overset{D}{\to} N(0,I_p)<br>$$<br>其中 $\theta_0$ 为参数的真实值，$I_p$ 为单位矩阵，$I(\theta_0)$中元素的值的大小与解得的$\hat{\theta}$的方差负相关</p>
<p>例如刚才的正态分布，</p>
 $$
\left\lbrack \begin{array}{cc}
\frac{n}{\sigma } & 0\\
0 & \frac{n}{\sqrt{2}\sigma^2 }
\end{array}\right\rbrack \left(\left\lbrack \begin{array}{c}
\hat{\mu} \\
\hat{\sigma^2 } 
\end{array}\right\rbrack -\left\lbrack \begin{array}{c}
\mu \\
\sigma^2 
\end{array}\right\rbrack \right)\overset{D}{\to} N\left(0,I_p \right)
$$ 
<p>所以</p>
 $$
\left\lbrack \begin{array}{c}
\hat{\mu} \\
\hat{\sigma^2 } 
\end{array}\right\rbrack \overset{D}{\to} N\left(\left\lbrack \begin{array}{c}
\mu \\
\sigma^2 
\end{array}\right\rbrack ,\left\lbrack \begin{array}{cc}
\frac{n^2 }{\sigma^2 } & 0\\
0 & \frac{n^2 }{{2\sigma }^4 }
\end{array}\right\rbrack ^{-1}\right)
$$ 
<p>那这样根据估计值 $[\hat{\mu},\hat{\sigma}^2]^T$ ，并且用该点处的费雪矩阵近似替换掉真实点处的费雪矩阵，得到对应95%的置信区间</p>
 $$
\left(\left\lbrack \begin{array}{c}
\hat{\mu} \\
\hat{\sigma^2 } 
\end{array}\right\rbrack -\left\lbrack \begin{array}{cc}
\frac{n}{\hat{\sigma} } & 0\\
0 & \frac{n}{\sqrt{2}{\hat{\sigma} }^2 }
\end{array}\right\rbrack ^{-1}\left\lbrack \begin{array}{c}
\Phi^{-1} \left(1-0\ldotp 025\right)\\
\Phi^{-1} \left(1-0\ldotp 025\right)
\end{array}\right\rbrack,\left\lbrack \begin{array}{c}
\hat{\mu} \\
\hat{\sigma^2 } 
\end{array}\right\rbrack +\left\lbrack \begin{array}{cc}
\frac{n}{\hat{\sigma} } & 0\\
0 & \frac{n}{\sqrt{2}{\hat{\sigma} }^2 }
\end{array}\right\rbrack ^{-1}\left\lbrack \begin{array}{c}
\Phi^{-1} \left(1-0\ldotp 025\right)\\
\Phi^{-1} \left(1-0\ldotp 025\right)
\end{array}\right\rbrack\right)
$$ 

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>费雪矩阵总体而言是相当有帮助的，对于确定估计值的准确性意义重大，而更多的有用性质尚未陈列，大家可以自行搜索了解</p>
<p>参考：复旦侯燕曦老师金融计量学课件</p>
<p>​            维基百科</p>
<p>​            CSDN <a href="https://blog.csdn.net/artifact1/article/details/80731417" target="_blank" rel="noopener">https://blog.csdn.net/artifact1/article/details/80731417</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/08/AlexNet%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/">
                AlexNet详细解读
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-08</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="AlexNet详细解读"><a href="#AlexNet详细解读" class="headerlink" title="AlexNet详细解读"></a>AlexNet详细解读</h1><p>  之前在自学计算机视觉与深度学习方向的论文，今天给大家带来的是很经典的一篇文章 ：《ImageNet Classification with Deep Convolutional Neural Networks》。纯粹是自学之后，自己的一点知识总结，如果有什么不对的地方欢迎大家指正。AlexNet的篇文章当中，我们可以主要从五个大方面去讲：ReLU，LPN，Overlapping Pooling，总体架构，减少过度拟合。重点介绍总体结构和减少过度拟合。</p>
<h2 id="1-ReLU-Nonlinearity"><a href="#1-ReLU-Nonlinearity" class="headerlink" title="1. ReLU Nonlinearity"></a>1. ReLU Nonlinearity</h2><p>一般神经元的激活函数会选择sigmoid函数或者tanh函数，然而Alex发现在训练时间的梯度衰减方面，这些非线性饱和函数要比非线性非饱和函数慢很多。在AlexNet中用的非线性非饱和函数是f=max(0,x)，即ReLU。实验结果表明，要将深度网络训练至training error rate达到25%的话，ReLU只需5个epochs的迭代，但tanh单元需要35个epochs的迭代，用ReLU比tanh快6倍。</p>
<h2 id="2-双GPU并行运行"><a href="#2-双GPU并行运行" class="headerlink" title="2. 双GPU并行运行"></a>2. 双GPU并行运行</h2><p>为提高运行速度和提高网络运行规模，作者采用双GPU的设计模式。并且规定GPU只能在特定的层进行通信交流。其实就是每一个GPU负责一半的运算处理。作者的实验数据表示，two-GPU方案会比只用one-GPU跑半个上面大小网络的方案，在准确度上提高了1.7%的top-1和1.2%的top-5。值得注意的是，虽然one-GPU网络规模只有two-GPU的一半，但其实这两个网络其实并非等价的。</p>
<h2 id="3-LRN局部响应归一化"><a href="#3-LRN局部响应归一化" class="headerlink" title="3. LRN局部响应归一化"></a>3. LRN局部响应归一化</h2><p><img src="https://img-blog.csdn.net/20180518200153219" alt="img"></p>
<p>ReLU本来是不需要对输入进行标准化，但本文发现进行局部标准化能提高性能。</p>
<p>其中a代表在feature map中第i个卷积核(x,y)坐标经过了ReLU激活函数的输出，n表示相邻的几个卷积核。N表示这一层总的卷积核数量。k, n, α和β是hyper-parameters，他们的值是在验证集上实验得到的，其中k = 2，n = 5，α = 0.0001，β = 0.75。</p>
<p>这种归一化操作实现了某种形式的横向抑制，这也是受真实神经元的某种行为启发。</p>
<p>卷积核矩阵的排序是随机任意，并且在训练之前就已经决定好顺序。这种LPN形成了一种横向抑制机制。</p>
<h2 id="4-Overlapping-Pooling"><a href="#4-Overlapping-Pooling" class="headerlink" title="4. Overlapping Pooling"></a>4. Overlapping Pooling</h2><p>池层是相同卷积核领域周围神经元的输出。池层被认为是由空间距离s个像素的池单元网格的组成。也可以理解成以大小为步长对前面卷积层的结果进行分块，对块大小为的卷积映射结果做总结，这时有。然而，Alex说还有的情况，也就是带交叠的Pooling，顾名思义这指Pooling单元在总结提取特征的时候，其输入会受到相邻pooling单元的输入影响，也就是提取出来的结果可能是有重复的(对max pooling而言)。而且，实验表示使用 带交叠的Pooling的效果比的传统要好，在top-1和top-5上分别提高了0.4%和0.3%，在训练阶段有避免过拟合的作用。</p>
<h2 id="5-总体结构"><a href="#5-总体结构" class="headerlink" title="5. 总体结构"></a>5. 总体结构</h2><p>如果说前面的ReLU、LRN、Overlapping Pooling是铺垫的话，那么它们一定是为这部分服务的。</p>
<p>因为这才是全文的重点！！！理解这里才是把握住这篇的论文的精华！</p>
<p><img src="https://img-blog.csdn.net/20180518202244353" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190222100954397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4Ym95NjE=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1689929-063fb60285b6ed42.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="img"></p>
<p>首先总体概述下：</p>
<p>  AlexNet为8层结构，其中前5层为卷积层，后面3层为全连接层；学习参数有6千万个，神经元有650,000个<br>  AlexNet在两个GPU上运行；<br>  AlexNet在第2,4,5层均是前一层自己GPU内连接，第3层是与前面两层全连接，全连接是2个GPU全连接；<br>  RPN层第1,2个卷积层后；<br>  Max pooling层在RPN层以及第5个卷积层后。<br>  ReLU在每个卷积层以及全连接层后。<br>  卷积核大小数量：</p>
<p>conv1:96 11<em>11</em>3(个数/长/宽/深度)</p>
<p>conv2:256 5<em>5</em>48</p>
<p>conv3:384 3<em>3</em>256</p>
<p>conv4: 384 3<em>3</em>192</p>
<p>conv5: 256 3<em>3</em>192</p>
<p>ReLU、双GPU运算：提高训练速度。（应用于所有卷积层和全连接层）</p>
<p>重叠pool池化层：提高精度，不容易产生过度拟合。（应用在第一层，第二层，第五层后面）</p>
<p>局部响应归一化层(LRN)：提高精度。（应用在第一层和第二层后面）</p>
<p>Dropout：减少过度拟合。（应用在前两个全连接层）<br>第1层分析：</p>
<p><img src="https://img-blog.csdn.net/20180518203413676" alt="img"><br>第一层输入数据为原始图像的227<em>227</em>3的图像（最开始是224<em>224</em>3，为后续处理方便必须进行调整）,这个图像被11<em>11</em>3（3代表深度，例如RGB的3通道）的卷积核进行卷积运算，卷积核对原始图像的每次卷积都会生成一个新的像素。卷积核的步长为4个像素，朝着横向和纵向这两个方向进行卷积。由此，会生成新的像素；（227-11）/4+1=55个像素(227个像素减去11，正好是54，即生成54个像素，再加上被减去的11也对应生成一个像素)，由于第一层有96个卷积核，所以就会形成55<em>55</em>96个像素层，系统是采用双GPU处理，因此分为2组数据：55<em>55</em>48的像素层数据。</p>
<p>重叠pool池化层：这些像素层还需要经过pool运算（池化运算）的处理，池化运算的尺度由预先设定为3<em>3，运算的步长为2，则池化后的图像的尺寸为：（55-3）/2+1=27。即经过池化处理过的规模为27</em>27*96.</p>
<p>局部响应归一化层(LRN)：最后经过局部响应归一化处理，归一化运算的尺度为5<em>5；第一层卷积层结束后形成的图像层的规模为27</em>27*96.分别由96个卷积核对应生成，这96层数据氛围2组，每组48个像素层，每组在独立的GPU下运算。<br>第2层分析：</p>
<p><img src="https://img-blog.csdn.net/20180518221411890" alt="img"><br>第二层输入数据为第一层输出的27<em>27</em>96的像素层（为方便后续处理，这对每幅像素层进行像素填充），分为2组像素数据，两组像素数据分别在两个不同的GPU中进行运算。每组像素数据被5<em>5</em>48的卷积核进行卷积运算，同理按照第一层的方式进行：（27-5+2<em>2）/1+1=27个像素，一共有256个卷积核，这样也就有了27</em>27*128两组像素层。</p>
<p>重叠pool池化层：同样经过池化运算，池化后的图像尺寸为（27-3）/2+1=13，即池化后像素的规模为2组13<em>13</em>128的像素层。</p>
<p>局部响应归一化层(LRN)：最后经过归一化处理，分别对应2组128个卷积核所运算形成。每组在一个GPU上进行运算。即共256个卷积核，共2个GPU进行运算。<br>第3层分析</p>
<p><img src="https://img-blog.csdn.net/20180518223031687" alt="img"><br>第三层输入数据为第二层输出的两组13<em>13</em>128的像素层（为方便后续处理，这对每幅像素层进行像素填充），分为2组像素数据，两组像素数据分别在两个不同的GPU中进行运算。每组像素数据被3<em>3</em>128的卷积核（两组，一共也就有3<em>3</em>256）进行卷积运算，同理按照第一层的方式进行：（13-3+1<em>2）/1+1=13个像素，一共有384个卷积核，这样也就有了13</em>13*192两组像素层。<br>第4层分析:</p>
<p><img src="https://img-blog.csdn.net/20180518223330629" alt="img"></p>
<p>第四层输入数据为第三层输出的两组13<em>13</em>192的像素层（为方便后续处理，这对每幅像素层进行像素填充），分为2组像素数据，两组像素数据分别在两个不同的GPU中进行运算。每组像素数据被3<em>3</em>192的卷积核进行卷积运算，同理按照第一层的方式进行：（13-3+1<em>2）/1+1=13个像素，一共有384个卷积核，这样也就有了13</em>13*192两组像素层。<br>第5层分析：</p>
<p><img src="https://img-blog.csdn.net/20180518223635261" alt="img"></p>
<p>第五层输入数据为第四层输出的两组13<em>13</em>192的像素层（为方便后续处理，这对每幅像素层进行像素填充），分为2组像素数据，两组像素数据分别在两个不同的GPU中进行运算。每组像素数据被3<em>3</em>192的卷积核进行卷积运算，同理按照第一层的方式进行：（13-3+1<em>2）/1+1=13个像素，一共有256个卷积核，这样也就有了13</em>13*128两组像素层。</p>
<p>重叠pool池化层：进过池化运算，池化后像素的尺寸为（13-3）/2+1=6，即池化后像素的规模变成了两组6<em>6</em>128的像素层，共6<em>6</em>256规模的像素层。<br>第6层分析：</p>
<p><img src="https://img-blog.csdn.net/20180518223855977" alt="img"><br>第6层输入数据的尺寸是6<em>6</em>256，采用6<em>6</em>256尺寸的滤波器对第六层的输入数据进行卷积运算；每个6<em>6</em>256尺寸的滤波器对第六层的输入数据进行卷积运算生成一个运算结果，通过一个神经元输出这个运算结果；共有4096个6<em>6</em>256尺寸的滤波器对输入数据进行卷积，通过4096个神经元的输出运算结果；然后通过ReLU激活函数以及dropout运算输出4096个本层的输出结果值。</p>
<p>很明显在第6层中，采用的滤波器的尺寸（6<em>6</em>256）和待处理的feature map的尺寸（6<em>6</em>256）相同，即滤波器中的每个系数只与feature map中的一个像素值相乘；而采用的滤波器的尺寸和待处理的feature map的尺寸不相同，每个滤波器的系数都会与多个feature map中像素相乘。因此第6层被称为全连接层。<br>第7层分析：</p>
<p><img src="https://img-blog.csdn.net/20180519092620718" alt="img"><br>第6层输出的4096个数据与第7层的4096个神经元进行全连接，然后经由ReLU和Dropout进行处理后生成4096个数据。<br>第8层分析：</p>
<p><img src="https://img-blog.csdn.net/20180519092826659" alt="img"></p>
<p>第7层输入的4096个数据与第8层的1000个神经元进行全连接，经过训练后输出被训练的数值。</p>
<h2 id="6-减少过度拟合"><a href="#6-减少过度拟合" class="headerlink" title="6. 减少过度拟合"></a>6. 减少过度拟合</h2><h3 id="6-1-数据增益"><a href="#6-1-数据增益" class="headerlink" title="6.1 数据增益"></a>6.1 数据增益</h3><p>增强图片数据集最简单和最常用的方法是在不改变图片核心元素（即不改变图片的分类）的前提下对图片进行一定的变换，比如在垂直和水平方向进行一定的唯一，翻转等。</p>
<p>AlexNet用到的第一种数据增益的方法：是原图片大小为256<em>256中随机的提取224</em>224的图片，以及他们水平方向的映像。</p>
<p>第二种数据增益的方法就是在图像中每个像素的R、G、B值上分别加上一个数，用到 方法为PCA。对于图像每个像素，增加以下量 ：</p>
<p><img src="https://img-blog.csdn.net/20180519094519363" alt="img"><br>p是主成分，lamda是特征值，alpha是N(0，0.1)高斯分布中采样得到的随机值。此方案名义上得到自然图像的重要特性，也就是说，目标是不随着光照强度和颜色而改变的。此方法降低top-1错误率1%。<br>6.2 Dropout</p>
<p>结合多个模型的预测值是减少错误的有效方法，但是对于训练时间用好几天的大型神经网络太耗费时间。Dropout是有效的模型集成学习方法，具有0.5的概率讲隐藏神经元设置输出为0。运用了这种机制的神经元不会干扰前向传递也不影响后续操作。因此当有输入的时候，神经网络采样不用的结构，但是这些结构都共享一个权重。这就减少了神经元适应的复杂性。测试时，用0.5的概率随机失活神经元。dropout减少了过拟合，也使收敛迭代次数增加一倍。</p>
<h2 id="7-学习细节"><a href="#7-学习细节" class="headerlink" title="7. 学习细节"></a>7. 学习细节</h2><p>AlexNet训练采用的是随机梯度下降 (stochastic gradient descent)，每批图像大小为128，动力为0.9，权重衰减为0.005,（Alexnet认为权重衰减非常重要，但是没有讲为什么）</p>
<p>对于权重值的更新规则如下：</p>
<p><img src="https://img-blog.csdn.net/2018051909591899" alt="img"><br>其中i是迭代指数，v是动力变量，ε是学习率，是目标关于w、对求值的导数在第i批样例上的平均值。我们用一个均值为0、标准差为0.01的高斯分布初始化了每一层的权重。我们用常数1初始化了第二、第四和第五个卷积层以及全连接隐层的神经元偏差。该初始化通过提供带正输入的ReLU来加速学习的初级阶段。我们在其余层用常数0初始化神经元偏差。<br>  对于所有层都使用了相等的学习率，这是在整个训练过程中手动调整的。我们遵循的启发式是，当验证误差率在当前学习率下不再提高时，就将学习率除以10。学习率初始化为0.01，在终止前降低三次。作者训练该网络时大致将这120万张图像的训练集循环了90次，在两个NVIDIA GTX 580 3GB GPU上花了五到六天。</p>
<h2 id="8-实验结果"><a href="#8-实验结果" class="headerlink" title="8. 实验结果"></a>8. 实验结果</h2><p>ILSVRC2010比赛冠军方法是Sparse coding,这之后(AlexNet前)报道最好方法是SIFT+FVs。CNN方法横空出世，远超传统方法。</p>
<p><img src="https://img-blog.csdn.net/20180519100236278" alt="img"></p>
<p>ILSVRC-2012，Alex参加比赛，获得冠军，远超第二名SIFT+FVs。</p>
<p><img src="https://img-blog.csdn.net/20180519100534494" alt="img"><br>定量分析：</p>
<p><img src="https://img-blog.csdn.net/20180519100835132" alt="img"><br>图3显示了卷积层学到的有频率和方向选择性的卷积核，和颜色斑点(color blob)。GPU 1 (color-agnostic)和GPU 2(color-specific)学习到的卷积核并不一样。不一样的原因是3.5中的受限连接(restricted connectivity)。</p>
<p>图4显示，即使目标偏离中心，也可以被识别出来，比如mite。top-5预测结果是reasonable的，比如leopard的预测的可能结果是其他类型的猫科动物。但是也存在对intended focus的模糊问题，就是网络不知道我们到底想识别图片中的什么物体，比如cherry,分类结果是dalmatian,网络显然关注的是dog。</p>
<p>网络最后4096-d隐藏层产生的是feature activations是另一个重要指标。如果两张图像产生欧氏距离相近的feature activation vectors,那么网络的higher levels就认为他们是相似的。使用此度量，可以实现较好的图像检索。<br>通过欧氏距离计算两个4096维度效率太低，可以使用自动编码压缩向量成二进制码。这比直接在原始像素上使用自动编码效果更好。因为在raw pixels上使用quto-encoder，没用到标签数据，只是检索有相似边缘模式(similar patterns of edges)的图像,却不管他们语义(semantically)上是否相似。</p>
<h2 id="9-探讨"><a href="#9-探讨" class="headerlink" title="9.探讨"></a>9.探讨</h2><p>深度很重要，去掉任一层，性能都会降低。</p>
<p>为了简化实验，没有使用非监督预训练。但是当有足够计算能力扩大网络结构，而没增加相应数据时，非监督预训练可能会有所帮助。</p>
<p>虽然通过增大网络结构和增加训练时长可以改善网络，但是我们与达到人类视觉系统的时空推理能力(infero-temporal pathway of the human visual system)还相距甚远。所以，最终希望能将CNN用到视频序列分析中，视频相对静态图像有很多有用的时间结构信息。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/08/%E5%8D%B7%E7%A9%8D%E4%B8%AD%E7%9A%84stride%E5%92%8Cpadding/">
                卷積中的stride和padding
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-08</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="卷積神經網路-Convolutional-neural-network-CNN-卷積計算中的步伐-stride-和填充-padding"><a href="#卷積神經網路-Convolutional-neural-network-CNN-卷積計算中的步伐-stride-和填充-padding" class="headerlink" title="卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)"></a>卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</h1><hr>
<p><strong>卷積神經網路(Convolutional neural network, CNN)其他相關連結我也一起列上來*<br>*</strong>NN-2–1 <a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-卷積運算-池化運算-856330c2b703" target="_blank" rel="noopener">卷積神經網路(Convolutional neural network, CNN) — 卷積運算、池化運算</a><br>NN-2–2<a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-cnn運算流程-ecaec240a631" target="_blank" rel="noopener"> 卷積神經網路(Convolutional neural network, CNN) — CNN運算流程</a><br>NN-2–3 <a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-卷積計算的倒傳遞推導與稀疏矩陣觀點來看卷積計算-e82ac16e510f" target="_blank" rel="noopener">卷積神經網路(Convolutional neural network, CNN):卷積計算的倒傳遞推導與稀疏矩陣觀點來看卷積計算</a><br>NN-2–4 <a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-卷積計算中的步伐-stride-和填充-padding-94449e638e82" target="_blank" rel="noopener">卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</a><br>NN-2–5 <a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-1-1卷積計算在做什麼-7d7ebfe34b8" target="_blank" rel="noopener">卷積神經網路(Convolutional neural network, CNN): 1×1卷積計算在做什麼</a></p>
<hr>
<p><img src="https://miro.medium.com/max/60/1*hjn1l4rN8jwS3vD5pTvUwQ.png?q=20" alt="img"></p>
<p><img src="https://miro.medium.com/max/1278/1*hjn1l4rN8jwS3vD5pTvUwQ.png" alt="img"></p>
<p>一般看到的卷積介紹，大概就像上圖，圖會因為你的kernel map大小做完卷積後變的更小，實際上卷積怎麼執行可以參考我之前寫的:<br><a href="https://medium.com/@chih.sheng.huang821/卷積神經網路-convolutional-neural-network-cnn-卷積運算-池化運算-856330c2b703" target="_blank" rel="noopener">卷積神經網路(Convolutional neural network, CNN) — 卷積運算、池化運算</a></p>
<p>Note: <strong>(2019/01/15增加)</strong>一般卷積網路過程中，除了Input image不稱為Feature map外，中間產生的圖我們都稱之為Feature map，原因很簡單就是這些中間產生的圖都是為了「描繪出該任務所應該產生對應的特徵資料」，這也呼應Yann LeCun, Yoshua Bengio &amp; Geoffrey Hinton寫的<a href="https://www.nature.com/articles/nature14539" target="_blank" rel="noopener">Deep Learning</a>第一句話寫的「Deep learning allows computational models that are composed of multiple processing layers to learn representations of data with multiple levels of abstraction」，深度學習過程就是在學資料的特性，所以中間出來的結果都是特徵資料，在影像因為是2D，所以用Feature map來稱呼。</p>
<p>所以一個卷積計算基本上有幾個部份:</p>
<p>\1. 輸入的圖: 假設大小是W × W。<br>\2. Filter (kernel map)大小是 ks × ks<br>\3. Stride: kernel map在移動時的步伐長度 S<br>\4. 輸出的圖大小為 new_height × new_width</p>
<p>上圖的例子<br>\1. 輸入的圖: W × W =10 × 10。<br>\2. Filter (kernel map): ks × ks=3 × 3<br>\3. Stride: S=1<br>\4. 輸出的圖大小為 new_height × new_width = 8 × 8</p>
<blockquote>
<p>上圖的範例產生了2個問題<br>\1. 是不是卷積計算後，卷積後的圖是不是就一定只能變小?<br>\2. 卷積計算是不是一次只能移動一格?</p>
</blockquote>
<p>所以如果你有玩過deep learning的API，卷積計算部份除了基本的input和filter (kernel map)通常還有兩個參數可以調(strides, padding)，這邊舉<a href="https://www.tensorflow.org/versions/r1.0/api_docs/python/tf/nn/conv2d" target="_blank" rel="noopener">tensorflow</a>的例子:<br>tf.nn.conv2d(input, filter, <strong><em>strides\</em></strong>, <strong><em>padding\</em></strong>, use_cudnn_on_gpu=None, data_format=None, name=None)</p>
<p><strong><em>strides\</em></strong>和 <strong><em>padding\</em></strong>這兩個參數就是在解決上面說的兩個問題。</p>
<hr>
<h2 id="是不是卷積計算後，卷積後的圖是不是就一定只能變小"><a href="#是不是卷積計算後，卷積後的圖是不是就一定只能變小" class="headerlink" title="是不是卷積計算後，卷積後的圖是不是就一定只能變小?"></a><strong>是不是卷積計算後，卷積後的圖是不是就一定只能變小?</strong></h2><p><strong>ANS: 用zero padding</strong></p>
<p>這個手法就是看你會消失多少的大小，在輸入的圖部份就給你加上0元素進去，這個手法稱為zero padding，實際作法如下圖。</p>
<p><img src="https://miro.medium.com/max/60/1*9kqLUr7bMEYryGNtAHyL8A.png?q=20" alt="img"></p>
<p><img src="https://miro.medium.com/max/2000/1*9kqLUr7bMEYryGNtAHyL8A.png" alt="img"></p>
<p>此刻的卷積計算如下，這樣卷積後的圖就不會變小了。</p>
<p><img src="https://miro.medium.com/max/60/1*GwxhjA7-FLIRrtl__RkRgg.png?q=20" alt="img"></p>
<p><img src="https://miro.medium.com/max/1522/1*GwxhjA7-FLIRrtl__RkRgg.png" alt="img"></p>
<p>上圖舉的例子是kernel map是3x3，假設kernel map為5x5，此刻在輸入的圖上下左右行和列都各加2行和2列的0，讓圖變成14x14，就可以了。</p>
<hr>
<h2 id="卷積計算是不是一次只能移動一格"><a href="#卷積計算是不是一次只能移動一格" class="headerlink" title="卷積計算是不是一次只能移動一格?"></a><strong>卷積計算是不是一次只能移動一格?</strong></h2><p><strong>ANS: 當然不是，也可以2格3格，但此時卷積後的圖就會變的更小。</strong></p>
<p><img src="https://miro.medium.com/max/60/1*Hy3dNn5siu4_q7jE7yO9eA.png?q=20" alt="img"></p>
<p><img src="https://miro.medium.com/max/1638/1*Hy3dNn5siu4_q7jE7yO9eA.png" alt="img"></p>
<p>在tensorflow，padding那邊給了兩個選項「padding = ‘VALID’」和「padding = ‘SAME’」</p>
<p><strong>padding = ‘VALID’ 等於最一開始敘述的卷積計算，圖根據filter大小和stride大小而變小。</strong></p>
<p>公式如下: new_height = new_width = (W — F + 1) / S （结果向上取整數，假設算出來結果是4.5，取5）</p>
<p>剛剛的例子<br>filter 3x3, stride=1, 卷積後的大小: (10–3+1)/1=8<br>filter 3x3, stride=2, 卷積後的大小: (10–3+1)/2=4</p>
<p><strong>padding = ‘SAME’，會用zero-padding的手法，讓輸入的圖不會受到kernel map的大小影響。</strong></p>
<p>new_height = new_width = W / S （结果向上取整數）</p>
<blockquote>
<p>剛剛的例子，filter 3x3, stride=2, 卷積後的大小: 10/2=5 (這邊我沒有做這張圖，可以自己想像一下，做法如下所述)<br>這邊的作法會先補zero-padding的0元素，然後在作stride=2的卷積，所以實際上是最(10+2)*(10+2)的圖做padding = ‘VALID’的事情，(12–3+1)/2=5。</p>
</blockquote>
<hr>
<h2 id="Padding補充說明-2019-01-15增加此內容"><a href="#Padding補充說明-2019-01-15增加此內容" class="headerlink" title="Padding補充說明 (2019/01/15增加此內容)"></a>Padding補充說明 (2019/01/15增加此內容)</h2><p>上面介紹的公式是針對tensorflow內建的function功能(「padding = ‘VALID’」和「padding = ‘SAME’」)，並不是一般算卷積後算新的feature map長寬的公式。</p>
<p>一般卷積後算新的feature map長寬的公式如下:</p>
<p><img src="https://miro.medium.com/max/60/1*NnC2iZDC0f8NlovHr9gwkg.png?q=20" alt="img"></p>
<p><img src="https://miro.medium.com/max/1238/1*NnC2iZDC0f8NlovHr9gwkg.png" alt="img"></p>
<p>floor(1.1)=1, floor(1.6)=1</p>
<p>這邊跟前面差別在這邊多了一個pad參數。</p>
<p>對應到caffe prototxt卷積的參數會這麼寫，如下(其他模組應該是一樣可以設pad參數)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">convolution_param &#123;</span><br><span class="line"> num_output: 32</span><br><span class="line"> pad: 1</span><br><span class="line"> kernel_size: 3</span><br><span class="line"> stride: 2</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>這代表卷積層filter數設定為32，filter的kernel size是3，步伐stride是2，pad是1。pad=1，表示圖外圈額外加1圈0，假設pad=2，圖外圈額外加2圈0，以此類推。<br>所以kernel size是3的時候，你希望卷積後圖的寬高不要變，pad就要設定為1<br>假設kernel size是5的時候，你希望卷積後圖的寬高不要變，pad就要設定為2<br>假設kernel size是7的時候，你希望卷積後圖的寬高不要變，pad就要設定為3</p>
<p>Note: 因為一般大多只會用到卷積後，Feature map寬高會依據kernel size縮小一點(「padding = ‘VALID’」)或Feature map寬高不變(「padding = ‘SAME’」)，鮮少搞一些特殊的功能，比如1×1卷積還要加pad=1，這樣出來的圖會比原本大一圈，而且這一圈還全為0。<br>而且一般卷積網路都是希望卷積後圖越來越小(整體MACC計算量才會小)，除了segmentation和一些multi-scale object detection等才會用到deconv.或是一些upsample的方法把feature map放大。<br>Tensorflow是提供簡單的api，你就不需要自己去算pad要設多少，直接下strin即可(如下說明)，多方便阿。<br><code>**padding**</code>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</p>
<h4 id="456"><a href="#456" class="headerlink" title="456"></a>456</h4>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/08/Why%20does%20overlapped%20pooling%20help%20reduce%20overfitting%20in%20conv%20nets/">
                Why does overlapped pooling help reduce overfitting in conv nets
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-08</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Why-does-overlapped-pooling-help-reduce-overfitting-in-conv-nets"><a href="#Why-does-overlapped-pooling-help-reduce-overfitting-in-conv-nets" class="headerlink" title="Why does overlapped pooling help reduce overfitting in conv nets?"></a><a href="https://stats.stackexchange.com/questions/283261/why-does-overlapped-pooling-help-reduce-overfitting-in-conv-nets" target="_blank" rel="noopener">Why does overlapped pooling help reduce overfitting in conv nets?</a></h1><p>I am going to answer this with the pooling example given above with some modifications. Let us say we have three <code>1D</code> features as given below.</p>
<p>[0 0 5 0 0 6 0 0 3 0 0 4 0 0]</p>
<p>[0 0 0 5 0 6 0 0 0 3 0 4 0 0]</p>
<p>[0 0 5 0 0 6 0 0 3 0 4 0 0 0]</p>
<p>When pooled using <code>z=2</code> and <code>s=2</code>, all 3 features lead to the same result as obtained above, that is</p>
<p>[0, 5, 6, 0, 3, 4, 0]</p>
<p>However when we use <code>z=3</code> and <code>s=2</code>, we get the following results respectively</p>
<p>[5, 5, 6, 3, 3, 4, 0]</p>
<p>[0, 5, 6, 0, 3, 4, 0]</p>
<p>[5, 5, 6, 3, 4, 4, 0]</p>
<p>Therefore, with overlapping pooling, we get three different results as opposed to one result when do not use overlapping. This is due to information loss when <code>z=s</code> which in this case leads to <strong>reduction</strong> in the amount of data available to train the network, i.e from 3 examples to 1 example. The shrinkage in the data size makes the training model overfit.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/08/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5summary/">
                对称矩阵summary
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-08</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="机器学习-线性代数基础-5-1-最重要的矩阵：对称矩阵"><a href="#机器学习-线性代数基础-5-1-最重要的矩阵：对称矩阵" class="headerlink" title="机器学习 线性代数基础 | 5.1 最重要的矩阵：对称矩阵"></a>机器学习 线性代数基础 | 5.1 最重要的矩阵：对称矩阵</h2><h3 id="5-1-最重要的矩阵：对称矩阵"><a href="#5-1-最重要的矩阵：对称矩阵" class="headerlink" title="5.1  最重要的矩阵：对称矩阵"></a><strong>5.1  最重要的矩阵：对称矩阵</strong></h3><p>在对数据进行降维与压缩的运算处理过程中，有一类矩阵扮演了极其重要的角色，那就是对称矩阵。在线性代数的理论与实践中，我们将对称矩阵称之为“最重要的”矩阵丝毫不显夸张。</p>
<p>对称矩阵除了“自身与转置后的结果相等”这个最浅显、基本的性质外，还拥有许多重要的高级特性。在对角化的运算讨论中，我们会发现实数对称矩阵一定能够对角化，并且能够得到一组标准正交的特征向量。同时，任意一个矩阵A同他自身的转置矩阵<img src="./pics/640-20200308114054559.png" alt="img">)相乘都能得到一个对称矩阵，我们在本小节中就将重点关注<img src="./pics/640-20200308114054525.png" alt="img">这类对称矩阵并细致的讨论他的特征值所具有的重要性质，这些基础知识将会为后续的高级主题打下坚实的基础，希望大家不要错过。</p>
<h3 id="5-1-1-对称矩阵基本特性回顾"><a href="#5-1-1-对称矩阵基本特性回顾" class="headerlink" title="5.1.1 对称矩阵基本特性回顾"></a><strong>5.1.1 对称矩阵基本特性回顾</strong></h3><p>首先，我们简要的回顾一下在之前的章节中所介绍过的关于对称矩阵的一些重要基本特性：</p>
<p>如果一个矩阵<strong><em>S\</em></strong>的所有数据项都满足<img src="pics/00831rSTgy1gcmdogc0l1j30290100gb.jpg" alt="img">)的相等关系，那么这个矩阵就被称作是一个对称矩阵。通俗的说，一个对称矩阵通过转置操作得到的结果仍然是他自身，即满足：<img src="./pics/640-20200308114054634.png" alt="img">的运算要求。我们从这里面还可以推断出对阵矩阵<strong><em>S\</em></strong>所蕴含的一个前提条件：他必须是一个方阵。</p>
<p>我们还讲过，有一种获取对称矩阵的简单方法：一个矩阵乘以自己的转置矩阵，即<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">，其所得到的运算结果必然是一个对称矩阵，关于这个结论的证明方法也非常简单，我们简单看一下：</p>
<p><img src="./pics/640-20200308114054518.png" alt="img"></p>
<p>这个等式满足关于矩阵对称的基本定义。</p>
<h3 id="5-1-2-实对称矩阵一定可以对角化"><a href="#5-1-2-实对称矩阵一定可以对角化" class="headerlink" title="5.1.2 实对称矩阵一定可以对角化"></a><strong>5.1.2 实对称矩阵一定可以对角化</strong></h3><p>我们在这里只讨论实数范围内的对称矩阵问题。</p>
<p>在上一章的内容里我们讲过，对于一个任意的方阵，如果他的特征值两两不同，那么特征值所对应的特征向量彼此之间满足线性无关，这个方阵可以被对角化。如果方阵有相同的特征值，他很可能存在线性相关的特征向量，那么如果发生了这种情况，该方阵就不能够被对角化了。</p>
<p>但是，这种情况在对称矩阵身上是不会发生的。请大家牢牢记住：对于任意一个实数对称矩阵而言，他都一定可以被对角化。换句话说，对于一个对称矩阵，无论他的特征值是否重复，他的特征向量都一定满足线性无关。</p>
<p>在这里，具体的证明过程我们不展开，大家有兴趣可以查阅相关的资料。</p>
<h3 id="5-1-3-特征向量标准正交"><a href="#5-1-3-特征向量标准正交" class="headerlink" title="5.1.3 特征向量标准正交"></a><strong>5.1.3 特征向量标准正交</strong></h3><p>任意一个实对称矩阵都可以获得一组标准正交的特征向量。这可以说是对称矩阵里我认为最好的一个性质了，在这里我们用一个简单的方法来描述一下这个性质以及他的推导证明过程。</p>
<p>首先，实对称矩阵<strong><em>S\</em></strong>一定能够被对角化，可以被写成<img src="pics/00831rSTgy1gcmdpfcpkzj303400r0k4.jpg" alt="img">)的形式，其中对角矩阵<img src="./pics/640-20200308114054570.png" alt="img">的各元素一定均由实数构成，并且最为关键的一点是任何一个对称矩阵分解得到的特征向量矩阵都可以是标准正交矩阵。</p>
<p>为什么这么说呢，我们可以简单的看一个等式推导过程：</p>
<p>首先对矩阵<strong><em>S\</em></strong>进行矩阵分解，得到：<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcgVflSTtES2ykOQlJrnVrBlC1wicJwJvtL2icFw9wTqATkeOiaqp6VO9TQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)。由于矩阵<strong><em>S\</em></strong>是一个对称矩阵，满足<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcku45axLrw3RqbBGj7p4Sklv5zVdpUZducSF1clbQWjV6vM5kibMHwng/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的关系，于是有：</p>
<p><img src="./pics/640-20200308114054580.png" alt="img">。</p>
<p>那么，想要使得上面的等式相等，我们就需要满足对应位置上的元素相等，即：<img src="./pics/640-20200308114054619.png" alt="img">)，对此我们再进一步，就可以将其整理成<img src="./pics/640-20200308114054594.png" alt="img">)的漂亮形式。这恰恰说明了，我们此时获取的特征向量之间是满足标准正交关系的，我们可以将<strong><em>X\</em></strong>换记作正交矩阵的符号<strong><em>Q\</em></strong>，同时结合<img src="./pics/640-20200308114054611.png" alt="img">)这个基本特性，我们就可以把实对称矩阵的对角化过程变换成更好的形式，写作：<img src="./pics/640-20200308114054622.png" alt="img">。</p>
<h3 id="5-1-4-对称矩阵的分解形式"><a href="#5-1-4-对称矩阵的分解形式" class="headerlink" title="5.1.4 对称矩阵的分解形式"></a><strong>5.1.4 对称矩阵的分解形式</strong></h3><p>将对称矩阵<strong><em>S\</em></strong>分解成标准正交的特征向量只是其中的一种形式而已，由定义式<img src="./pics/640-20200308114054647.png" alt="img">我们可以得知，显然，特征向量是一个方向上的向量集合，不一定非得满足长度为1的要求，但是我们仍然可以通过直觉感受到一个事实，那就是一旦把特征向量都设置为单位向量，那么会在实践的过程中收获很多简化和美好。这个在后面的几节内容里，我们会不断的感受到由此带来的巨大好处。</p>
<p>此时，我们知道了对称矩阵<strong><em>S\</em></strong>一定可以得到由一组标准正交特征向量所构成的特征矩阵<strong><em>Q\</em></strong>。即，矩阵<strong><em>Q\</em></strong>可以表示成：<img src="./pics/640-20200308114054672.png" alt="img">的形式， 我们进一步将等式<img src="./pics/640-20200308114054717.png" alt="img">)进行展开，可以得到<img src="./pics/640-20200308114054672-3638854.png" alt="img">的完整相乘形式。</p>
<p>这个式子是非常重要的，接下来我们进一步将其做展开运算，将矩阵<strong><em>S\</em></strong>写成一组矩阵相加的形式，你就会发现他的精彩之处：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcIicn5aDl8aIcicXx3GmjsUdVsMU17nuy7VibWQwMRChia7T5icG5s428ywA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">。</p>
<p>在这一组标准正交向量当中，每一个<img src="./pics/640-20200308114054679.png" alt="img">相乘所得到的结果项都是一个秩为1并且与矩阵<strong><em>S\</em></strong>维数相等的方阵。同时他还满足方阵与方阵之间相乘的结果为0这个性质，也可以广义的理解为方阵之间满足“正交”。</p>
<p>最终，任意一个n阶对称矩阵<strong><em>S\</em></strong>都可以分解成n个秩1方阵乘以各自权重系数<img src="./pics/640-20200308114054752.png" alt="img">然后相加的结果。</p>
<h3 id="5-1-5-与的秩"><a href="#5-1-5-与的秩" class="headerlink" title="5.1.5 )与的秩"></a><strong>5.1.5 <img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)与<img src="./pics/640-20200308114054807.png" alt="img">的秩</strong></h3><p>在本书前面的章节中，我们介绍过这样一个结论，对于任意一个m×n形状的矩阵<strong><em>A\</em></strong>，他的列向量中线性无关向量的个数等于其行向量中线性无关向量的个数。</p>
<p>换句话说，也就是任意矩阵的行秩等于列秩，即满足：<img src="./pics/640-20200308114054733.png" alt="img">。这个结论可以从线性方程组消元化简的角度去思考，这样大家就会很容易明白了。</p>
<p>我们再看看矩阵<strong><em>A\</em></strong>和<img src="./pics/640-20200308114054749.png" alt="img">的秩之间的关系：</p>
<p>我们从零空间的角度入手去理解这个问题。即，如果方程<strong><em>Ax=0\</em></strong>和方程<img src="./pics/640-20200308114054804.png" alt="img">)是同解方程，那么他们就拥有相同的零空间，由于<strong><em>A\</em></strong>和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">这两个矩阵的列的个数相等，都为 n，因此，就可以推断出他们的列空间的维数相同，均为：<strong><em>n***</em></strong>−N(A)***，换句话说，也就能够推出二者的秩相等。</p>
<p>好的，那就让我们按照这个思路来推进：</p>
<p>首先，如果满足方程<strong><em>Ax=0\</em></strong>成立，方程两边同时乘以转置矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJclDFCYpPPQ3aOcCwEUarLP1zr9gDw0AmJCx8DnMDmPhrnjakbRjZmew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)，很明显，等式<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJce8ZA2jrNnvjXVwL1jIZEmZuicG8bFA3lDFcn6fWPZ3HtMj8thic78yfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)同样能够成立。因此，我们可以说如果<strong><em>x\</em></strong>是方程<strong><em>Ax=0\</em></strong>的解，则能够推得出<strong><em>x\</em></strong>也一定是方程<img src="./pics/640-20200308114054765.png" alt="img">的解。</p>
<p>那么反过来呢，如果方程<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcY6ujibyA4J1pRMTkZ3G5iboRe1F2sDOpjgOY62eaZricJPHgWdu8K84xg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)成立，我们将方程两边同时乘以向量<img src="./pics/640-20200308114054775.png" alt="img">)，即方程<img src="./pics/640-20200308114054790.png" alt="img">)当然也一定能够成立，我们对这个等式稍微整理一下，就可以得到<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcM8OiaD6C5ESaG3OMR4jHUTWLGdkibkn38R7sY2wQFyQVgDd85vcZvT2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)这个更加简洁的形式，从中可以看出一定能够满足<strong><em>Ax=0\</em></strong>成立。此时，我们可以说如果<strong><em>x\</em></strong>是方程<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcY6ujibyA4J1pRMTkZ3G5iboRe1F2sDOpjgOY62eaZricJPHgWdu8K84xg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的解，那么他一定也是方程<strong><em>Ax=0\</em></strong>的解。</p>
<p>于是，这个问题我们就说清楚了：方程<strong><img src="./pics/640-20200308114054817.png" alt="img"></strong>和方程<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJce8ZA2jrNnvjXVwL1jIZEmZuicG8bFA3lDFcn6fWPZ3HtMj8thic78yfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)是一对同解的方程，矩阵<strong><em>A\</em></strong>和矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)这两个矩阵拥有相同的零空间，因此我们就解释清楚了矩阵<strong><em>A\</em></strong>和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">秩相等的问题。</p>
<p>那么同样的，我们由此不难发现也一定有矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJclDFCYpPPQ3aOcCwEUarLP1zr9gDw0AmJCx8DnMDmPhrnjakbRjZmew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的秩相等。那么这下好了，在<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcp02jRb44qpVmWLe2xdmcsHpSnMASoB0OcwibSF07f1pYSuBGOicCNXWQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">这个相等关系的纽带连接下，我们就有了以下这个结论：</p>
<p><img src="./pics/640-20200308114054843.png" alt="img"></p>
<p>从等式中可以看出，他们的秩都是相等的。</p>
<h3 id="5-1-6-对称矩阵的正定性描述"><a href="#5-1-6-对称矩阵的正定性描述" class="headerlink" title="5.1.6 对称矩阵的正定性描述"></a><strong>5.1.6</strong> <strong><img src="./pics/640-20200308114054862.png" alt="img">对称矩阵的正定性描述</strong></h3><p>最后，我们来聚焦一下对称矩阵特征值的问题，我们先介绍一组概念：如果一个矩阵的所有特征值都为正，我们称他是“正定的”矩阵，如果均为非负（即，最小的特征值为0），相当于结论上稍稍弱了一些，我们称之为“半正定的”矩阵，如果他含有负的特征值，那么显然，他是非正定的。</p>
<p>那么换句话说，对于一个对称矩阵而言，从特征值的正负性角度来看的话，他一定是正定、半正定或非正定的其中一种。</p>
<p>就正定性而言，一般的对称矩阵其实没有太多的特殊性，但是由任意矩阵<strong><em>A\</em></strong>乘以他的转置矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJclDFCYpPPQ3aOcCwEUarLP1zr9gDw0AmJCx8DnMDmPhrnjakbRjZmew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)得到的对称矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">，则具备非常好的特殊性质。即，他的特征值一定是非负的，换句话说，他至少是半正定的。</p>
<p>我们简单的说明一下为什么。</p>
<p>我们还是从特征向量的定义式子<img src="./pics/640-20200308114054884.png" alt="img">)入手进行分析，我们将等式两边同时乘以向量<img src="./pics/640-20200308114054964.png" alt="img">)，得到<img src="./pics/640-20200308114054893.png" alt="img">)这个新等式，由于特征向量必须非零，所以必然存在有<img src="./pics/640-20200308114054982.png" alt="img">)的不等关系。换句话说，此时等式<img src="./pics/640-20200308114054906.png" alt="img">)左侧的正负性就决定了右侧<img src="./pics/640-20200308114054922.png" alt="img">的正负性。</p>
<p>那么问题就来了，如果要满足正定性（或半正定性）的要求，那么就一定要满足所有的<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)都为正（或非负）的要求，等价于<img src="./pics/640-20200308114054981.png" alt="img">)的计算结果恒为正（或非负），这在<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcjhCQv699nEYqG44B4VdoAU7TLed5GMALZrPDoCJvbjWbvltKykicl7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的条件下能够保证成立么？我们将其代入到等式中发现，这个是可以保证成立的：</p>
<p><img src="./pics/640-20200308114054933.png" alt="img">，</p>
<p>此时，如果矩阵<strong><em>A\</em></strong>的各列满足线性无关，由于向量<strong><em>x\</em></strong>是非零的，因此就能够保证所有的<strong><em>Ax***</em></strong>≠0***都成立，那么就有<img src="./pics/640-20200308114054948.png" alt="img">)恒成立。此时，对称矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)所有的特征值都满足<img src="./pics/640-20200308114055045.png" alt="img">，因此矩阵是正定的。</p>
<p>如果矩阵<strong><em>A\</em></strong>的各列线性相关，那么也就是说有x≠0而<strong><em>Ax=0\</em></strong>的情况存在，此时就只能保证<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcibgic2DWqRPVbR5Za6Eb2PBND3LENoDoiauoARYMicJ3aZmhH4M1dgxGBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)（存在等于零的可能性），对称矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)就存在值为0的特征值<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">。因此，此时的矩阵是半正定的。</p>
<p>那么此时就可以继续挖掘出结论：实对称矩阵中非零特征值的个数等于该矩阵的秩。这个结论非常明显：因为矩阵<strong><em>A\</em></strong>与相似对角化后的矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcFPgH3uA0h6V41ujDm4EJjXUcCXicneKCwqOwDEvicIxxlxQIqzQ0ODJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)拥有相同的特征值，同时由于相似性可知：这两个矩阵的秩相等。而<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcFPgH3uA0h6V41ujDm4EJjXUcCXicneKCwqOwDEvicIxxlxQIqzQ0ODJA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">最容易看出非零特征值的个数和秩的相等关系，从而结论得证。</p>
<p>我们总结一下，对称矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的所有特征值都满足非负性，特别的，如果矩阵<strong><em>A\</em></strong>的列向量满足线性无关，则该矩阵是一个正定矩阵，其特征值均为正。</p>
<h3 id="5-1-7-与的特征值"><a href="#5-1-7-与的特征值" class="headerlink" title="5.1.7 )与的特征值"></a><strong>5.1.7 <img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJchJt4fLISBkOfHRgMia7okcSjkrvXME32jxXkwUm5nHkZPmQWbSEHfibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)与<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的特征值</strong></h3><p>最后，我们来看看<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)这两个对称矩阵的特征值满足什么样的关系。我告诉大家，这个问题的结论非常完美：<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">拥有完全一样的非零特征值。</p>
<p>我们从两个方向入手进行证明：说明如果<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)是矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值，那么他也是矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJchJt4fLISBkOfHRgMia7okcSjkrvXME32jxXkwUm5nHkZPmQWbSEHfibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值；反过来，如果<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)是矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值，那么他同样也是矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的特征值。</p>
<p>我们假设矩阵<strong><em>A\</em></strong>的维度是m×n，矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的一个非零特征值是<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)，对应的特征向量是<strong><em>x\</em></strong>，那么依据定义有：<img src="./pics/640-20200308114055217.png" alt="img">)，我们将等式两边同时乘以矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJclDFCYpPPQ3aOcCwEUarLP1zr9gDw0AmJCx8DnMDmPhrnjakbRjZmew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)，即满足：<img src="./pics/640-20200308114055172.png" alt="img">)的相等关系，我们稍作整理就可以得到一个漂亮的等式：<img src="./pics/640-20200308114055198.png" alt="img">)，于是我们看出，矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值仍然是<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)，对应的特征向量为<img src="./pics/640-20200308114055256.png" alt="img">。</p>
<p>那么反过来呢，证明过程也是非常简单的，已知矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcn8SKOn31jOL8QZQC9ib1QKSM8lah9JuQA3hDwmfKZWgiageLlL5W4kdw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和对应的特征向量<strong><em>y\</em></strong>，依据定义有：<img src="./pics/640-20200308114055221.png" alt="img">)满足等式成立，两边同时乘以矩阵<strong><em>A\</em></strong>，可以得到：<img src="./pics/640-20200308114055261.png" alt="img">)的相等关系，也是对其稍作整理，就有：<img src="./pics/640-20200308114055304.png" alt="img">)，这个过程同样说明了，如果<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJc6vwIsmHUPDLckTd4K3mJeHBv30YkCnUSofkhibVFnT7J5bPMmEZwWUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)是<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)的特征值，那么他也一定是<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的特征值。</p>
<p>这里，我们就给大家解释清了：<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">这两个对称矩阵拥有完全相同的非负特征值。</p>
<h3 id="5-1-8-对称矩阵的性质总结"><a href="#5-1-8-对称矩阵的性质总结" class="headerlink" title="5.1.8 对称矩阵的性质总结"></a><strong>5.1.8 对称矩阵的性质总结</strong></h3><p>在这一节里，我们讲解了对称矩阵的诸多重要性质和漂亮结论。他们不是零散的概念，而是可以构成一个知识网络。我在本节的最后给大家串联一下这些知识点，大家共同思考一下里面的内在关联：</p>
<p>对于任意的一个m×n形状的矩阵A，有如下性质：</p>
<p>● 矩阵A和转置矩阵<img src="./pics/640-20200308114055284.jpeg" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJclDFCYpPPQ3aOcCwEUarLP1zr9gDw0AmJCx8DnMDmPhrnjakbRjZmew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)相乘的结果<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">都是对称矩阵；</p>
<p>● 矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">都能够被对角化，且都可以通过矩阵分解，获得一组标准正交的特征向量；</p>
<p>● 矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJchJt4fLISBkOfHRgMia7okcSjkrvXME32jxXkwUm5nHkZPmQWbSEHfibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)分别是n阶和m阶的方阵，一般情况下他们的维度都是不等的，但是他们的秩却一定满足相等关系，即满足：<img src="./pics/640-20200308114055425.png" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">的相等关系；</p>
<p>● 对于矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">而言，他的特征值一定都是非负的，特别的，如果矩阵A的列向量满足线性无关，那么他的特征值全部为正，即为正定矩阵；</p>
<p>● 矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcdOXGiaU6cAWlGoRia6HEt1zGhY4zXh8wEHxzhWwEaEZ8Ajic8ibSUaWqBA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)和矩阵<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcaXiaA0icTnQt8pEDnRfwwTY261gwL1x9HvgFUJWHiaZpdp9sWZIsPBQLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34yTW25WCkMeqfiaC2KmfQgJcr8DULn2icdRficEXf8vGINhNQLgDzOEXhmBuGKq36xCDCvePbibEEF0Ww/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">拥有完全相同的非零特征值，非零特征值的个数与矩阵A的秩相等。</p>
<p>熟悉、掌握这五个重要结论，将会为本章后面几节的内容扫清最大的数学障碍，帮助大家更好的掌握相关的高级内容。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/">
                二叉树遍历
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-07</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"><a href="#二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）" class="headerlink" title="二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）"></a>二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）</h1><p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>
<p>四种主要的遍历思想为：</p>
<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gclqutmnqsj30bo0afwfg.jpg" alt="二叉树"></p>
<p>前序遍历：1  2  4  5  7  8  3  6 </p>
<p>中序遍历：4  2  7  5  8  1  3  6</p>
<p>后序遍历：4  7  8  5  2  6  3  1</p>
<p>层次遍历：1  2  3  4  5  6  7  8</p>
<h3 id="一、前序遍历"><a href="#一、前序遍历" class="headerlink" title="一、前序遍历"></a>一、前序遍历</h3><p>1）根据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，很容易写出递归版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(root.val+<span class="string">"  "</span>);</span><br><span class="line">			preOrderTraverse1(root.left);</span><br><span class="line">			preOrderTraverse1(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>2）现在讨论非递归的版本：<br>根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。对于任意一个结点node，具体步骤如下：</p>
<p>a)访问之，并把结点node入栈，当前结点置为左孩子；</p>
<p>b)判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复a)步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		TreeNode pNode = root;</span><br><span class="line">		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">				System.out.<span class="built_in">print</span>(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">				pNode = pNode.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">				pNode = node.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>






<h3 id="二、中序遍历"><a href="#二、中序遍历" class="headerlink" title="二、中序遍历"></a>二、中序遍历</h3><p>1)根据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，很容易写出递归版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">			inOrderTraverse1(root.left);</span><br><span class="line">			System.out.<span class="built_in">print</span>(root.val+<span class="string">"  "</span>);</span><br><span class="line">			inOrderTraverse1(root.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>






<p>2）非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		TreeNode pNode = root;</span><br><span class="line">		<span class="keyword">while</span> (pNode != null || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pNode != null) &#123;</span><br><span class="line">				<span class="built_in">stack</span>.push(pNode);</span><br><span class="line">				pNode = pNode.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">				TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">				System.out.<span class="built_in">print</span>(node.val+<span class="string">"  "</span>);</span><br><span class="line">				pNode = node.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h3 id="三、后序遍历"><a href="#三、后序遍历" class="headerlink" title="三、后序遍历"></a>三、后序遍历</h3><p>1）根据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点，很容易写出递归版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">			postOrderTraverse1(root.left);</span><br><span class="line">			postOrderTraverse1(root.right);</span><br><span class="line">			System.out.<span class="built_in">print</span>(root.val+<span class="string">"  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>




<p>2）非递归的代码，暂且不写</p>
<h3 id="四、层次遍历"><a href="#四、层次遍历" class="headerlink" title="四、层次遍历"></a>四、层次遍历</h3><p>层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedList&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="built_in">queue</span>.offer(root);</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">			TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">			System.out.<span class="built_in">print</span>(node.val+<span class="string">"  "</span>);</span><br><span class="line">			<span class="keyword">if</span> (node.left != null) &#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node.right != null) &#123;</span><br><span class="line">				<span class="built_in">queue</span>.offer(node.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、深度优先遍历"><a href="#五、深度优先遍历" class="headerlink" title="五、深度优先遍历"></a>五、深度优先遍历</h3><p>其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthOrderTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedList&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	<span class="built_in">stack</span>.push(root);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">		TreeNode node = <span class="built_in">stack</span>.pop();</span><br><span class="line">		System.out.<span class="built_in">print</span>(node.val+<span class="string">"  "</span>);</span><br><span class="line">		<span class="keyword">if</span> (node.right != null) &#123;</span><br><span class="line">			<span class="built_in">stack</span>.push(node.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node.left != null) &#123;</span><br><span class="line">			<span class="built_in">stack</span>.push(node.left);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/07/Gram%E7%9F%A9%E9%98%B5/">
                Gram矩阵
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-07</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>Gram Matrix实际上可看做是feature之间的偏心协方差矩阵（即没有减去均值的协方差矩阵），在feature map中，每一个数字都来自于一个特定滤波器在特定位置的卷积，因此每个数字就代表一个特征的强度，而Gram计算的实际上是两两特征之间的相关性，哪两个特征是同时出现的，哪两个是此消彼长的等等，同时，Gram的对角线元素，还体现了每个特征在图像中出现的量，因此，Gram有助于把握整个图像的大体风格。有了表示风格的Gram Matrix，要度量两个图像风格的差异，只需比较他们Gram Matrix的差异即可。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/07/Jupyter%20Notebook%20%E5%9C%A8%20macOS%20%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                Jupyter Notebook 在 macOS 系统上的快捷键
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-07</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Jupyter-Notebook-在-macOS-系统上的快捷键"><a href="#Jupyter-Notebook-在-macOS-系统上的快捷键" class="headerlink" title="Jupyter Notebook 在 macOS 系统上的快捷键"></a>Jupyter Notebook 在 macOS 系统上的快捷键</h1><p>通过 Anaconda 来管理 Python 的开发环境，其自带 <strong>Jupyter Notebook</strong> 。借此整理下 <strong>Jupyter Notebook</strong> 在 <strong>macOS 系统</strong>上常用的快捷键。</p>
<blockquote>
<p>Jupyter Notebook 有两种不同的键盘输入模式。「编辑模式」允许你在单元格中键入代码或文本，并由<strong>绿色单元格边框</strong>指示;「命令模式」将键盘绑定到Notebook命令，并由带有<strong>蓝色左边距的灰色单元格边框</strong>指示。</p>
</blockquote>
<h4 id="Mac-OS-X-修饰键"><a href="#Mac-OS-X-修饰键" class="headerlink" title="Mac OS X 修饰键"></a>Mac OS X 修饰键</h4><table>
<thead>
<tr>
<th>符号</th>
<th>修饰键</th>
<th></th>
<th>符号</th>
<th>修饰键</th>
</tr>
</thead>
<tbody><tr>
<td>⌘</td>
<td>Command</td>
<td></td>
<td>⇧</td>
<td>Shift</td>
</tr>
<tr>
<td>⌃</td>
<td>Control</td>
<td></td>
<td>↩</td>
<td>Return</td>
</tr>
<tr>
<td>⌥</td>
<td>Option</td>
<td></td>
<td>␣</td>
<td>Space</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>⇥</td>
<td>Tab</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>功能</th>
<th align="left">快捷键</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td>「命令模式」</td>
<td align="left">Esc</td>
<td align="right">蓝色的单元格</td>
</tr>
<tr>
<td>「编辑模式」</td>
<td align="left">Enter</td>
<td align="right">绿色的单元格</td>
</tr>
<tr>
<td>代码补全或缩进</td>
<td align="left">⇥</td>
<td align="right">「编辑模式」输入字母按 Tab 会补全，没有字母则缩进</td>
</tr>
<tr>
<td>向右缩进</td>
<td align="left">⌘ + ]</td>
<td align="right">「编辑模式」缩进</td>
</tr>
<tr>
<td>向左缩进</td>
<td align="left">⌘ + [</td>
<td align="right">「编辑模式」解除缩进</td>
</tr>
<tr>
<td>全选</td>
<td align="left">⌘ + A</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>撤销</td>
<td align="left">⌘ + Z</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>跳到本单元开头</td>
<td align="left">⌘ + ↑</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>跳到本单元末尾</td>
<td align="left">⌘ + ↓</td>
<td align="right">「编辑模式」⌘ + End 同样的功能</td>
</tr>
<tr>
<td>跳到本行的最左边/开头</td>
<td align="left">⌘ + ←</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>跳到本行的最右边/末尾</td>
<td align="left">⌘ + →️</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>注释/撤销整行代码</td>
<td align="left">⌘ + /</td>
<td align="right">「编辑模式」</td>
</tr>
<tr>
<td>运行本单元，选择下行单元</td>
<td align="left">⇧ + ↩</td>
<td align="right">「编辑模式」、「命令模式」</td>
</tr>
<tr>
<td>运行本单元</td>
<td align="left">⌃ + ↩︎</td>
<td align="right">「编辑模式」、「命令模式」</td>
</tr>
<tr>
<td>运行本单元，插入下行新单元</td>
<td align="left">⌥ + ↩</td>
<td align="right">「编辑模式」、「命令模式」</td>
</tr>
<tr>
<td>选中上一个单元</td>
<td align="left">↑</td>
<td align="right">「命令模式」;「编辑模式」下可光标上移</td>
</tr>
<tr>
<td>选中下一个单元</td>
<td align="left">↓</td>
<td align="right">「命令模式」;「编辑模式」下可光标下移</td>
</tr>
<tr>
<td>删除选中单元</td>
<td align="left">D , D</td>
<td align="right">「命令模式」下连续按两个 D 字母键</td>
</tr>
<tr>
<td>撤销删除选中单元</td>
<td align="left">Z</td>
<td align="right">「命令模式」下按 Z 字母键</td>
</tr>
<tr>
<td>在本单元上方插入新单元</td>
<td align="left">A</td>
<td align="right">「命令模式」下按 A 字母键</td>
</tr>
<tr>
<td>在本单元下方插入新单元</td>
<td align="left">B</td>
<td align="right">「命令模式」下按 B 字母键</td>
</tr>
<tr>
<td>剪切单元格</td>
<td align="left">X</td>
<td align="right">「命令模式」下按 X 字母键</td>
</tr>
<tr>
<td>复制单元格</td>
<td align="left">C</td>
<td align="right">「命令模式」下按 C 字母键</td>
</tr>
<tr>
<td>粘贴单元格到上方</td>
<td align="left">⇧ + V</td>
<td align="right">「命令模式」</td>
</tr>
<tr>
<td>粘贴单元格到下方</td>
<td align="left">V</td>
<td align="right">「命令模式」下 V 字母键</td>
</tr>
<tr>
<td>更改单元格为Code</td>
<td align="left">Y</td>
<td align="right">「命令模式」下按 Y 字母键</td>
</tr>
<tr>
<td>更改单元格为Markdown</td>
<td align="left">M</td>
<td align="right">「命令模式」下按 M 字母键</td>
</tr>
<tr>
<td>更改单元格为Raw</td>
<td align="left">R</td>
<td align="right">「命令模式」下按 R 字母键</td>
</tr>
<tr>
<td>更改单元格为标题Heading1 - Heading6</td>
<td align="left">1 - 6</td>
<td align="right">「命令模式」下按1到6数字键*</td>
</tr>
<tr>
<td>合并选中的单元格</td>
<td align="left">⇧ + M</td>
<td align="right">「编辑模式」如果只有一个单元格被选中，则合并当前及以下单元格</td>
</tr>
<tr>
<td>保存当前Notebook</td>
<td align="left">⌘ + S</td>
<td align="right">「编辑模式」、「命令模式」或者「命令模式」下按 S 字母键</td>
</tr>
<tr>
<td>显示快捷键提示</td>
<td align="left">H</td>
<td align="right">「命令模式」下按 H 字母键，可自定义快捷键</td>
</tr>
<tr>
<td>中断Notebook内核</td>
<td align="left">I, I</td>
<td align="right">「命令模式」下连续按两个 I (interrupt) 字母键</td>
</tr>
<tr>
<td>重启Notebook内核</td>
<td align="left">0, 0</td>
<td align="right">「命令模式」下连续按两个0数字键</td>
</tr>
</tbody></table>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/05/multi-view%20learning/">
                multi-view learning
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="多视图学习（multi-view-learning）"><a href="#多视图学习（multi-view-learning）" class="headerlink" title="多视图学习（multi-view learning）"></a>多视图学习（multi-view learning）</h1><p><strong>概括：</strong>多视图学习就是360度，全方位无死角的欣赏（学习）然后得到最接近真实值的判定。</p>
<p>话说那么一天啊，一个人和一个蚂蚁在对话，他们看着一个米饭粒，人说，这个米饭粒胖嘟嘟的一定很香，蚂蚁说：你胡说，这米粒明明是长方形的，你干嘛说他胖嘟嘟的。然后他们就吵得面红耳赤，就去问上帝，这米究竟是什么样子的。上帝说：你们都没有错，人看到的是三维的世界，所以他们能看到立体的东西，而蚂蚁只能看到二维的，所以蚂蚁只能看到平面的。</p>
<p>从上面的小故事我们可以看出，多视图学习就是从多个角度去学习，然后数据进行预测提高准确性。</p>
<h1 id="一-半监督学习"><a href="#一-半监督学习" class="headerlink" title="一 半监督学习"></a>一 半监督学习</h1><p>半监督学习问题在真实世界中大量存在,以下列举几例:</p>
<p>在文本分类中,例如,垃圾邮件过滤问题,所有邮件都可以作为未标记数据,标记数据的获取要求用户标注哪些是垃圾邮件,哪些不是,如果使用传统的监督学习方法,需要用户标记上千个邮件作为样本,才能使训练的学习器有较好的过滤性能,而几乎没有用户愿意花如此多的时间标记邮件，在只有少量的用户标记邮件和大量的未标记邮件的情况下,使用半监督学习方法训练垃圾邮件过滤器可能是一个好的选择。在图像处理中,例如,计算机辅助医学图像分析问题,可以从医院获得大量的医学图像作为未标记数据,但如果要求医学专家把这些图像中的病灶都标识出来,往往是不现实的,一般只能对少量医学图像中的病灶进行标识,所以需要使用半监督学习方法来减少对标记数据的需求，在自然语言处理中,例如,句法分析问题,为了训练一个好的句法分析器需要构造句子/句法树,这是一项十分耗时的工作,构造几千个句法树可能要耗费一个语言学家几年的时间，而可以作为未标记数据使用的句子是普遍存在的,考虑未标记数据的半监督学习能解决语言学家的困难，上述实例表明,随着信息技术的飞速发展,我们面临的问题是,数据大量存在,但获取数据的标记却需要耗费大量的人力物力，传统的监督学习方法在标记数据较少的情况下很难获得好的预测性能”半监督学习正是为了解决这类问题而提出，在理论和实际中都具有重要意义。</p>
<h2 id="1-1多视图的半监督学习"><a href="#1-1多视图的半监督学习" class="headerlink" title="1.1多视图的半监督学习"></a>1.1多视图的半监督学习</h2><h3 id="1-1-1多视图数据"><a href="#1-1-1多视图数据" class="headerlink" title="1.1.1多视图数据"></a>1.1.1多视图数据</h3><p>在一些实际问题中，对于同一事物可以从多种不同的途径或不同的角度对其进行描述,这多种描述构成事物的多个视图(multi view)。本文用带下标的xi表示第i个数据点,用带上标的x(t)表示数据的第i个视图,则多视图数据可表示为xi={x1x2,…,xn}其中,表示视图的个数,多视图数据在真实世界中广泛存在,以下列举几例:在网页分类问题中,既可以根据网页本身包含的信息来对网页进行分类,也可以利用链接到该网页的超链接所包含的信息来进行分类,这样,网页数据就可以用两个视图表示,刻画网页本身包含信息的特征集构成第一个视图,刻画超链接所包含信息的特征集构成第二个视图,在电视片段的识别问题中,既可以根据视频中包含的信息来进行识别,也可以根据音频中包含的信息来进行识别,所以电视数据可以用视频和音频这两个视图表示”在自然语言理解问题中,同一语义对象,可以用不同的语言来表达,这些不同的语言描述就构成了此语义对象的不同视图表示,上述示例中,多视图用于表示数据的不同特征集,多视图还可以用于表示数据的不同来源;例如对于同一个数据源,用不同的采集装置进行采集,这多个采集结果构成了数据的不同视图;另外,多视图还可以用于表示数据间的不同关系;例如,学术论文的分类问题中,论文间既有参考文献的引用关系,也有作者的合作关系,可以把不同的关系用不同的视图来表示;有一些文献涉及多模态(multimodal)学习问题,但不同的文献中模态一词的含义不同”狭义的多模态是指人的不同感官,如视觉,听觉,嗅觉!触觉等;视觉所对应的图像或文字信息,和听觉所对应的声音信息,就构成多模态数据;广义的模态数据是指对于一个事物,通过不同的方法收集到的数据”例如在人脸识别中,可能收集到人脸的2D图像和3D形状模型,这就构成人脸数据的两个模态;在指纹识别中,用不同传感器采集的一个指纹的多种不同印痕,构成指纹数据的多个模态;对比多模态数据和多视图数据的概念可以看出,多视图的含义里包含了多模态,多视图可以表示更广泛的实际问题;</p>
<h3 id="1-3-2多视图数据的表示"><a href="#1-3-2多视图数据的表示" class="headerlink" title="1.3.2多视图数据的表示"></a>1.3.2多视图数据的表示</h3><p>数据的表示问题是机器学习的重点和难点问题之一，因为学习效果往往受到数据表示方法的影响。对于客观世界的对象,常常提取它的特征，然后用特征向量表示此对象，即xi={x1, x2… xn}了,其中n代表特征的个数。人们希望提取的特征体现了此对象的本质，从而能够用这些特征学习到目标概念。然而，对于一个学习问题，需要的最小特征集是不可知的，在缺乏先验信息的情况下,只能提取尽可能多的特征,提供给学习器,期望学习器能获得更好的预测性能”另外，数据收集技术的发展，使得人们可以通过更加复杂多样的手段对事物进行描述，这也导致数据的特征较多。这些描述对象的特征中，有些特征具有不同的属性，因此不适合使用同一种学习器进行学习。例如上述电视片段的识别问题中，电视片段具有视频和音频两部分特征，这两部分特征更适合分别用图像识别方法和声音识别方法来学习。如果使用单视图(即用所有特征组成一个特征向量，来表示电视片段，将无法选择一种既适合图像又适合声音的普适学习方法，在这种情况下，使用多视图的表示法较为适合，即把数据表示成多个特征集,然后在每个特征集上可以用不同的学习方法进行学习。</p>
<p>即使数据的特征能够使用同一种学习器进行学习,多视图学习也可能比单视图学习具有优势”例如上述网页分类问题中,网页本身所包含的信息和指向该网页的超链接所包含的信息均由单词构成,网页视图和超链接视图都可以表示成文本向量的形式,在这两个视图上可以用同一种学习器进行学习”然而,如果要把这两个视图合成一个视图,则得到的特征向量失去了原有的意义,而且可能增加了特征空间的维数,从而给学习带来不必要的困难”另外,数据的多视图表示方法还能够发挥各个视图的优势,利用未标记数据达到协同学习的目的,以改善学习性能,这一点接下来将具体介绍。</p>
<h3 id="1-3-3多视图的半监督学习"><a href="#1-3-3多视图的半监督学习" class="headerlink" title="1.3.3多视图的半监督学习"></a>1.3.3多视图的半监督学习</h3><p>在多视图的半监督学习中,一方面数据有多个视图,即x=xt,另一方面数据由标记数据集L和未标记数据集U组成,学习算法应考虑如何利用多个视图蕴含的信息和未标记数据蕴含的信息,来辅助传统的监督学习.在该领域具有代表性的算法有A.Blum和T.Mitchell提出的协同训练算法 (co一training)。该算法假设数据有两个视图，首先在两个视图上利用标记数据分别训练出一个分类器，然后，在协同训练过程中，每个分类器从未标记数据中挑选若干预测置信度较高的数据进行标记,并把标记后的数据加入另一个分类器的标记数据集中,以便对方利用这些新标记的数据进行更新，此过程不断迭代进行，直到达到某个停止条件。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gciccan4njj30hj08cab3.jpg" alt="img"></p>
<p>上图展示了协同训练算法的主要思想，图中,Cl和C2分别代表两个类别的数据,用两个不同的颜色表示,X(l)和X(2)代表数据的两个不同视图，在视图X(1)中，这两个类别的数据可以被分类器很好地区别开来,而在视图X(2)中,这两个类别的数据混合分布,很难训练得到好的分类器，在这种情况下，用视图X(l)训练的分类器可以把它对未标记数据的分类结果中比较置信那些的未标记数据,连同它对那些未标记数据的分类结果,一起提供给视图X(2)上的分类器，然后，用视图x(2)训练的分类器能够利用从视图X(l)上得到的信息，排除自身的不确定性,从而提高用视图X(2)训练的分类器性能，反之亦然，多视图学习正是利用数据在不同的视图学习的难易程度不同，来发挥视图之间的相互作用,，优势互补，协同学习。自从协同训练算法被提出以后,多视图的半监督学习得到研究者的重视，涌现出了一批相关工作，并取得了很多研究以根据音频中包含的信息来进行识别，所以电视数据可以用视频和音频这两个视图表示，在自然语言理解问题中，同一语义对象，可以用不同的语言来表达，这些不同的语言描述就构成了此语义对象的不同视图表示。上述示例中，多视图用于表示数据的不同特征集，多视图还可以用于表示数据的不同来源。例如对于同一个数据源，用不同的采集装置进行采集，这多个采集结果构成了数据的不同视图。另外，多视图还可以用于表示数据间的不同关系。例如，学术论文的分类问题中，论文间既有参考文献的引用关系,也有作者的合作关系，可以把不同的关系用不同的视图来表示，有一些文献涉及多模态(multimodal)学习问题，但不同的文献中模态一词的含义不同。狭义的多模态是指人的不同感官，如视觉，听觉，嗅觉，触觉等视觉所对应的图像或文字信息，和听觉所对应的声音信息，就构成多模态数据。广义的多模态数据是指对于一个事物，通过不同的方法收集到的数据。例如在人脸识别中，可能收集到人脸的3D图像和3D形状模型，这就构成人脸数据的两个模态。在指纹识别中，用不同传感器采集的一个指纹的多种不同印痕，构成指纹数据的多个模态。对比多模态数据和多视图数据的概念可以看出，多视图的含义里包含了多模态，多视图可以表示更广泛的实际问题。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/03/01/%E7%AE%80%E5%8E%86/">
                简历
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-03-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="FDU-李云帆-Luke-Li"><a href="#FDU-李云帆-Luke-Li" class="headerlink" title="FDU 李云帆 [Luke Li]"></a>FDU 李云帆 [Luke Li]</h1><table>
<thead>
<tr>
<th>Skype</th>
<th>+86-15821154370</th>
</tr>
</thead>
<tbody><tr>
<td>Email</td>
<td><a href="mailto:16302010002@fudan.edu.cn">16302010002@fudan.edu.cn</a></td>
</tr>
<tr>
<td>Website</td>
<td><a href="http://liyunfan.fun/" target="_blank" rel="noopener">http://liyunfan.fun</a></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Fudan University 2016.09 - Expected 2021.05</th>
</tr>
</thead>
<tbody><tr>
<td>Software Engineering==transferred to Data Science in 2018</td>
</tr>
</tbody></table>
<h2 id="Educational-experience-and-honors"><a href="#Educational-experience-and-honors" class="headerlink" title="Educational experience and honors"></a>Educational experience and honors</h2><p><strong>TOEFL:112</strong>; <strong>GRE:326+3.5</strong> ; CET-6: 637</p>
<p><strong>GPA: 3.25/4.0</strong></p>
<p><strong>Second author</strong> of <a href="http://www.liyunfan.fun/%e2%9d%a4%ef%b8%8f%e6%96%87%e7%ab%a0%e5%8f%91%e8%a1%a8/Combined%20priority%20and%20path%20planning%20with%20a%20double-layer%20structure%20for%20multiple%20robots.pdf" target="_blank" rel="noopener">Combined priority and path planning with a double-layer structure for multiple robots</a></p>
<p><strong>2018 whole year,  Teaching Assistant</strong> for “ <strong>Introduction to computer systems</strong>“ (adaptation of CS213)</p>
<p><strong>Fall of 2018, Exchange experience</strong> at the *<em>University of California ,  Santa Cruz (UCSC) *</em></p>
<p><strong>2017.03 【Clover Software Development Innovation Competition】 Third Prize</strong></p>
<p><strong>2017.04 【* CTF Information Security Competition】 Star of the Future Award &amp; Third Prize</strong></p>
<p><strong>Member of ****** CTF team</strong> of Fudan University, 2017-2018</p>
<p><strong>2017.11, Third Prize - Fudan University Scholarship</strong></p>
<p>I was the Minister of Academics of the Students&#39; Union under department of Data Science since fall 2019.</p>
<h2 id="Intern-and-Research-Experience"><a href="#Intern-and-Research-Experience" class="headerlink" title="Intern and Research Experience"></a>Intern and Research Experience</h2><p>Fall 2020. <strong>Research intern</strong> at <a href="http://me.sjtu.edu.cn/teacher_directory1/caoqixin.html" target="_blank" rel="noopener">Prof. Qixin Cao</a>&#39;s <strong>RobotLab</strong>. <strong>Finished</strong> <a href="http://www.liyunfan.fun/%e2%9d%a4%ef%b8%8f%e6%96%87%e7%ab%a0%e5%8f%91%e8%a1%a8/Combined%20priority%20and%20path%20planning%20with%20a%20double-layer%20structure%20for%20multiple%20robots.pdf" target="_blank" rel="noopener"><strong>an article</strong></a> with Haili Wangon path planning for multi-robot scene <strong>as the second author</strong>. And is now in charge of <a href="http://www.liyunfan.fun/%e4%ba%a4%e9%80%9a%e5%a4%a7%e5%ad%a6%e6%99%ba%e8%83%bd%e6%9c%ba%e5%99%a8%e4%ba%ba%e5%ae%9e%e9%aa%8c%e5%ae%a4%e2%80%94%e2%80%94%e5%ba%b7%e5%a4%8d%e8%af%8a%e7%96%97%e5%bc%95%e5%af%bc%e4%b8%80%e4%bd%93%e5%8c%96%e7%b3%bb%e7%bb%9f/" target="_blank" rel="noopener">the smart-rehabilitation-system project</a>.</p>
<p>Spring 2019. <strong>Research intern</strong> at <a href="https://yangxu.info/" target="_blank" rel="noopener">Prof. Yang Xu</a>&#39;s <strong>Future Network Innovation Laboratory</strong>. Began to work on ways to model cache replacement algorithms to speed up simulations, to recognize request patterns and to find ways (mainly cache pollution attacks) to disrupt the locality of CDNs and corresponding countermeasures.</p>
<p>Fall 2017 and Spring 2018. <strong>Research intern</strong> at <strong>System Security Lab</strong> under supervision of <a href="https://yuanxzhang.github.io/" target="_blank" rel="noopener">Prof. Yuan Zhang</a> about the topic of Javascript RFCs through vulnerable WebView component in android systems.</p>
<p>Summer 2017. <strong>Backend engineer internship</strong> at ChenXi studio. I helped with the development of a web app for the school that involves generating and returning user-information-related-pictures, had 600+ users.</p>
<h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>Highly interest driven and self-motivating.</p>
<p>Strong learning abilities; strong sense of planning.</p>
<p>Pressure proof;highly resolved and self-disciplined; assiduous towards research.</p>
<h2 id="Skills-and-Interests"><a href="#Skills-and-Interests" class="headerlink" title="Skills and Interests"></a>Skills and Interests</h2><p>Self learned <a href="http://vision.stanford.edu/teaching/cs231n/" target="_blank" rel="noopener">CS231n</a>and <a href="https://www.bilibili.com/video/av62138405" target="_blank" rel="noopener">Pytorch tutorial</a></p>
<p>Excellent programing skills. Namely, proficiency in Java and Python; familiar with C++ and R, used JS and PHP before.</p>
<p>Currently interested in computer vision and robotics.</p>
<h2 id="In-school-project-experience"><a href="#In-school-project-experience" class="headerlink" title="In-school project experience"></a>In-school project experience</h2><h4 id="2016-012-Programming-A"><a href="#2016-012-Programming-A" class="headerlink" title="2016.012 Programming A"></a>2016.012 Programming A</h4><h6 id="Project-name-the-game-of-the-arena-chess"><a href="#Project-name-the-game-of-the-arena-chess" class="headerlink" title="Project name: the game of the arena chess"></a>Project name: the game of the arena chess</h6><p>100% completion, the realization of the JavaFX-based GUI, the corresponding user mouse and keyboard operation. </p>
<h4 id="2017-12-Object-Oriented-Design"><a href="#2017-12-Object-Oriented-Design" class="headerlink" title="2017.12 Object-Oriented Design"></a>2017.12 Object-Oriented Design</h4><h6 id="Project-name-2048-games"><a href="#Project-name-2048-games" class="headerlink" title="Project name: 2048 games"></a>Project name: 2048 games</h6><p>A C++ QT-based GUI2048 game, using depth search to achieve AI functionality. </p>
<h4 id="2017-06-Introduction-to-Web-Applications"><a href="#2017-06-Introduction-to-Web-Applications" class="headerlink" title="2017.06 Introduction to Web Applications"></a>2017.06 Introduction to Web Applications</h4><h6 id="Project-name-Image-sharing-website"><a href="#Project-name-Image-sharing-website" class="headerlink" title="Project name: Image sharing website"></a>Project name: Image sharing website</h6><p>A web interface. PHP + MySQL as backend, frontend HTML, CSS, JavaScript, user authentication with cookies, encryption using hashing with salt. </p>
<h4 id="2017-12-Data-Structure-and-Algorithm-Design"><a href="#2017-12-Data-Structure-and-Algorithm-Design" class="headerlink" title="2017.12 Data Structure and Algorithm Design"></a>2017.12 Data Structure and Algorithm Design</h4><h6 id="Project-name-Chess-AI"><a href="#Project-name-Chess-AI" class="headerlink" title="Project name: Chess AI"></a>Project name: Chess AI</h6><p>min-max search, alpha-beta pruning, search layer: 4.</p>
<h4 id="2017-12-Computer-System-Foundation-2"><a href="#2017-12-Computer-System-Foundation-2" class="headerlink" title="2017.12 Computer System Foundation (2)"></a>2017.12 Computer System Foundation (2)</h4><h6 id="Project-name-CLI-multi-threaded-chat-room"><a href="#Project-name-CLI-multi-threaded-chat-room" class="headerlink" title="Project name: CLI multi-threaded chat room"></a>Project name: CLI multi-threaded chat room</h6><p>thread pool monitoring message, specify ip+port to achieve message transmission.</p>
<h4 id="2018-06-Software-Engineering-Group-Work"><a href="#2018-06-Software-Engineering-Group-Work" class="headerlink" title="2018.06 Software Engineering (Group Work)"></a>2018.06 Software Engineering (Group Work)</h4><h6 id="Project-name-Calendar-Notepad"><a href="#Project-name-Calendar-Notepad" class="headerlink" title="Project name: Calendar Notepad"></a>Project name: Calendar Notepad</h6><p>This course focuses on design patterns and code refactoring. Responsible for backend development. </p>
<h4 id="2018-06-Computer-Graphics"><a href="#2018-06-Computer-Graphics" class="headerlink" title="2018.06 Computer Graphics"></a>2018.06 Computer Graphics</h4><h6 id="Project-name-WebGL-project"><a href="#Project-name-WebGL-project" class="headerlink" title="Project name: WebGL project"></a>Project name: WebGL project</h6><p>Draw a scene with WebGL, user keyboard event to achieve camera perspective change and omnidirectional movement, realize keyboard event control object visibility, realize keyboard event control transformation.</p>
<h4 id="2018-06-Neural-Network-and-Deep-Learning-Group-Work"><a href="#2018-06-Neural-Network-and-Deep-Learning-Group-Work" class="headerlink" title="2018.06 Neural Network and Deep Learning (Group Work)"></a>2018.06 Neural Network and Deep Learning (Group Work)</h4><h6 id="Project-name-Chinese-ancient-poetry-generation"><a href="#Project-name-Chinese-ancient-poetry-generation" class="headerlink" title="Project name: Chinese ancient poetry generation"></a>Project name: Chinese ancient poetry generation</h6><p>Based on TensorFlow framework, using LSTM.</p>
<h4 id="Fall-2018"><a href="#Fall-2018" class="headerlink" title="Fall 2018   /"></a>Fall 2018   /</h4><h6 id="exchanging-in-UCSC-no-projects"><a href="#exchanging-in-UCSC-no-projects" class="headerlink" title="exchanging in UCSC, no projects"></a>exchanging in UCSC, no projects</h6><h4 id="2019-06-Distributed-Systems"><a href="#2019-06-Distributed-Systems" class="headerlink" title="2019.06 Distributed Systems"></a>2019.06 Distributed Systems</h4><h6 id="Project-name-New-York-Taxi-Data-Analysis"><a href="#Project-name-New-York-Taxi-Data-Analysis" class="headerlink" title="Project name: New York Taxi Data Analysis"></a>Project name: New York Taxi Data Analysis</h6><p>Doing massive data analysis on Spark.</p>
<h4 id="2019-06-Advanced-Data-Science"><a href="#2019-06-Advanced-Data-Science" class="headerlink" title="2019.06 Advanced Data Science"></a>2019.06 Advanced Data Science</h4><h6 id="Project-name-Turkish-population-data-analysis"><a href="#Project-name-Turkish-population-data-analysis" class="headerlink" title="Project name: Turkish population data analysis"></a>Project name: Turkish population data analysis</h6><p>Doing massive data analysis on Spark. Machine learning algorithms applied.</p>
<h4 id="2019-06-Artificial-Intelligence-Group-Work"><a href="#2019-06-Artificial-Intelligence-Group-Work" class="headerlink" title="2019.06 Artificial Intelligence (Group Work)"></a>2019.06 Artificial Intelligence (Group Work)</h4><h6 id="Project-name-Gomoku-on-piskvorkGomoku-agent-implemented-with-MCTS"><a href="#Project-name-Gomoku-on-piskvorkGomoku-agent-implemented-with-MCTS" class="headerlink" title="Project name: Gomoku on piskvorkGomoku agent implemented with MCTS"></a>Project name: Gomoku on piskvorkGomoku agent implemented with MCTS</h6><p> ADP &amp; Threat-space search applied. </p>
<h4 id="2019-06-Social-Network-Mining-Group-Work"><a href="#2019-06-Social-Network-Mining-Group-Work" class="headerlink" title="2019.06 Social Network Mining (Group Work)"></a>2019.06 Social Network Mining (Group Work)</h4><h6 id="Project-name-Movie-recommendation-algorithms-for-users"><a href="#Project-name-Movie-recommendation-algorithms-for-users" class="headerlink" title="Project name: Movie recommendation algorithms for users"></a>Project name: Movie recommendation algorithms for users</h6><p>Using web crawlers to gather data (from <a href="https://www.douban.com/" target="_blank" rel="noopener">Douban</a>) and multiple recommendation algorithms to make reasonable choices of recommendation to users.</p>
<h4 id="2019-06-Statistical-machine-learning-Group-Work"><a href="#2019-06-Statistical-machine-learning-Group-Work" class="headerlink" title="2019.06 Statistical machine learning (Group Work)"></a>2019.06 Statistical machine learning (Group Work)</h4><h6 id="Project-name-Kaggle-Box-office-prediction"><a href="#Project-name-Kaggle-Box-office-prediction" class="headerlink" title="Project name: [Kaggle] Box office prediction"></a>Project name: [Kaggle] <a href="https://www.kaggle.com/c/tmdb-box-office-prediction/" target="_blank" rel="noopener">Box office prediction</a></h6><p>Using LightGBM for prediction. [Kaggle]Project name: Bilibili Data AnalysisUsing web crawlers to gather data (from <a href="https://bilibili.com/" target="_blank" rel="noopener">Bilibili</a>) for Data Analysis on video uploaders.</p>
<h4 id="2019-06-Financial-Time-Series-in-Data-Mining-Group-Work"><a href="#2019-06-Financial-Time-Series-in-Data-Mining-Group-Work" class="headerlink" title="2019.06 Financial Time Series in Data Mining (Group Work)"></a>2019.06 Financial Time Series in Data Mining (Group Work)</h4><h6 id="Project-name-Residential-electricity-usage-data-analysis"><a href="#Project-name-Residential-electricity-usage-data-analysis" class="headerlink" title="Project name: Residential electricity usage data analysis"></a>Project name: Residential electricity usage data analysis</h6><p>Using DTW for time series classification and LSTM for time series prediction. Data from Bureau of Shanghai Electric Power.</p>
<h6 id="Project-name-Time-series-analysis-on-search-engine-searches-for-keyword-quot-Big-Data-quot"><a href="#Project-name-Time-series-analysis-on-search-engine-searches-for-keyword-quot-Big-Data-quot" class="headerlink" title="Project name: Time series analysis on search engine searches for keyword &quot;Big Data&quot;"></a>Project name: Time series analysis on search engine searches for keyword &quot;Big Data&quot;</h6><p>Using web crawlers to gather data (from <a href="http://index.baidu.com/v2/index.html?from=pinzhuan#/" target="_blank" rel="noopener">Baidu Index</a>) to predict future market size of the &quot;Big Data&quot; industry. </p>
<h2 id="The-courses-that-I-have-finished-until-now"><a href="#The-courses-that-I-have-finished-until-now" class="headerlink" title="The courses that I have finished until now :"></a>The courses that I have finished until now :</h2><table>
<thead>
<tr>
<th><strong>Course Index</strong></th>
<th><strong>Course Name</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Math and Physics</strong></td>
<td></td>
</tr>
<tr>
<td>MATH120021</td>
<td>Advanced Mathematics A I</td>
</tr>
<tr>
<td>MATH120022</td>
<td>Advanced Mathematics A II</td>
</tr>
<tr>
<td>SOFT130039</td>
<td>Discrete Math I</td>
</tr>
<tr>
<td>SOFT130040</td>
<td>Discrete Math II</td>
</tr>
<tr>
<td>SOFT130079</td>
<td>Linear Algebra</td>
</tr>
<tr>
<td>PHYS120013</td>
<td>College Physics B I</td>
</tr>
<tr>
<td>PHYS120014</td>
<td>College Physics B II</td>
</tr>
<tr>
<td>PHYS120015</td>
<td>Fundamental Physics Experiments</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>English</strong></td>
<td></td>
</tr>
<tr>
<td>ENGL110012</td>
<td>Audio-visual English</td>
</tr>
<tr>
<td>ENGL110061</td>
<td>Essay Writing</td>
</tr>
<tr>
<td>ENGL110066</td>
<td>English for Business Communication</td>
</tr>
<tr>
<td>ENGL110068</td>
<td>Advanced English</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Programing</strong></td>
<td></td>
</tr>
<tr>
<td>SOFT120001</td>
<td>Programming A (Java)</td>
</tr>
<tr>
<td>SOFT130002</td>
<td>Introduction to Web Applications (PHP+JS+HTML+CSS)</td>
</tr>
<tr>
<td>SOFT130004</td>
<td>Data Structure and Algorithm Design (Python)</td>
</tr>
<tr>
<td>SOFT130006</td>
<td>Software Engineering (Java)</td>
</tr>
<tr>
<td>SOFT130059</td>
<td>Object-Oriented Programming in C++</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Data Mining</strong></td>
<td></td>
</tr>
<tr>
<td>DATA130001</td>
<td>Financial Time Series in Data Mining</td>
</tr>
<tr>
<td>DATA130007</td>
<td>Social Network Mining</td>
</tr>
<tr>
<td>DATA130014</td>
<td>Advanced Data Science</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Machine Learning</strong></td>
<td></td>
</tr>
<tr>
<td>DATA130008</td>
<td>Artificial Intelligence</td>
</tr>
<tr>
<td>DATA130011</td>
<td>Neural Network and Deep Learning</td>
</tr>
<tr>
<td>DATA130003</td>
<td>Statistical machine learning</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Computer System</strong></td>
<td></td>
</tr>
<tr>
<td>SOFT130056</td>
<td>Introduction to Computer Systems I</td>
</tr>
<tr>
<td>SOFT130057</td>
<td>Introduction to Computer Systems II</td>
</tr>
<tr>
<td>DATA130020</td>
<td>Database and Implementation</td>
</tr>
<tr>
<td>DATA130015</td>
<td>Large-scale Distributed Systems</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>Statistics</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DATA130005</td>
<td>Statistics: Principles, Methods and R (I)</td>
</tr>
<tr>
<td>DATA130004</td>
<td>Computational Statistics</td>
</tr>
<tr>
<td>DATA130009</td>
<td>Statistics: Principles, Methods and R (II)</td>
</tr>
</tbody></table>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/">因果卷积和扩展卷积</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/08/18/CasualCNN/">CasualCNN</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/08/18/%E6%97%B6%E9%97%B4%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C(TCN)%EF%BC%9A%E7%BB%93%E6%9E%84+pytorch%E4%BB%A3%E7%A0%81/">时间卷积网络(TCN)：结构+pytorch代码</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/07/19/%E3%80%90%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E3%80%91Stacked%20Hourglass%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">【人体姿态】Stacked Hourglass算法</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>