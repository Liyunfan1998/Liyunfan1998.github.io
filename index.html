<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Yunfan Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Hexo"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hexo"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>Hexo</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 4.2.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/archives">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Hexo</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/">
                因果卷积和扩展卷积
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-08-18</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="因果卷积（causal）与扩展卷积（dilated）之An-Empirical-Evaluation-of-Generic-Convolutional-and-Recurrent-Networks-for-Sequence-Modeling"><a href="#因果卷积（causal）与扩展卷积（dilated）之An-Empirical-Evaluation-of-Generic-Convolutional-and-Recurrent-Networks-for-Sequence-Modeling" class="headerlink" title="因果卷积（causal）与扩展卷积（dilated）之An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling"></a>因果卷积（causal）与扩展卷积（dilated）之An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling</h3><p>本文首发于<a href="https://www.cnblogs.com/fantastic123/p/9389128.html，这个博客也是我的，所以不是搬运他人的" target="_blank" rel="noopener">https://www.cnblogs.com/fantastic123/p/9389128.html，这个博客也是我的，所以不是搬运他人的</a></p>
<p>author：gswycf</p>
<p>　　最近在看关于NLP（自然语言处理）方面的文章，（其实不是自己要看），anyway，看了一个“An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling“，讲到了：虽然人们现在都在用RNN和LSTm去处理序列问题（sequence modeling），但是明显最近几年这些模型在这些问题上出现了瓶颈，你们之前都说CNN不适合处理sequence modeling问题，但其实并不是的，作者提出了一个普适的CNNN模型，在多个序列问题上和之前的RNN和LSTM比较，结果发现，CNN在这方面的能力确实是被低估了，CNN建立的model要比之前人们之前用的RNN要好很多，而且简洁。</p>
<p>　　这篇blog并不是要讲那篇文章，我可能会单独写一篇（看有没有时间），这篇blog主要是结束那篇文章中提出的两个概念：因果卷积（causal）与扩展卷积（dilated）</p>
<p>　　</p>
<p>　　因果卷积：</p>
<p>　　因为要处理序列问题（即要考虑时间问题，）就不能使用普通的CNN卷积，必须使用新的CNN模型，这个就是因果卷积的作用，看下面一个公式，对与序列问题（sequence modeling），主要抽象为，根据x1……xt和y1…..yt-1去预测yt，使得yt接近于实际值</p>
<p><img src="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/1383870-20180730100014982-1169540039.png" alt="img"></p>
<p>　　</p>
<p>　　我们根据图片来看下因果卷积的样子，下面这个图片来自：<a href="https://deepmind.com/blog/wavenet-generative-model-raw-audio/" target="_blank" rel="noopener">https://deepmind.com/blog/wavenet-generative-model-raw-audio/</a></p>
<p>​               <img src="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/1383870-20180730100824670-1288691528.png" alt="img"></p>
<p>　　上面的图片可以详细的解释因果卷积，但是问题就来，如果我要考虑很久之前的变量x，那么卷积层数就必须增加（自行体会）。。。卷积层数的增加就带来：梯度消失，训练复杂，拟合效果不好的问题，为了决绝这个问题，出现了扩展卷积（dilated）</p>
<p>　　扩展卷积：</p>
<p>　　对于因果卷积，存在的一个问题是需要很多层或者很大的filter来增加卷积的感受野。本文中，我们通过大小排列来的扩大卷积来增加感受野。扩大卷积（dilated convolution）是通过跳过部分输入来使filter可以应用于大于filter本身长度的区域。等同于通过增加零来从原始filter中生成更大的filter。</p>
<p>​                           <img src="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/1383870-20180730100217229-1516234421.gif" alt="img"></p>
<p>   这就可以解决因果卷积带来的问题，在示意图中，卷积感受野扩大了1,2,4,8倍。扩大卷积（dilated convolution）可以使模型在层数不大的情况下有非常大的感受野。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/08/18/CasualCNN/">
                CasualCNN
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-08-18</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="What-are-causal-convolutions"><a href="#What-are-causal-convolutions" class="headerlink" title="What are causal convolutions?"></a>What are causal convolutions?</h1><p><a href="https://arxiv.org/pdf/1609.03499.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.03499.pdf</a></p>
<p>The word causal comes from signal processing, in particular form the characterization of filters. Signals are functions of time and/or space. Filters are functions that remove certain aspects of a signal, leaving only features that you are interested in (e.g. certain frequencies or the positions of certain patterns). Linear filters are filters where, at each point in time and/or space, the output is determined by a weighted sum/integral of the input, i.e. by a convolution. A filter is called <em>causal</em> if the filter output does not depend on future inputs.</p>
<p>In WaveNet the current acoustic intensity that the neural network produces at time step <em>t</em> only depends on data before <em>t</em>. If the network is used to generate new data, then it obviously can’t depend on future data (since it has not been generated yet). During training it could, but then the network could not be used to generate new data. There are two ways of implementing a causal filter in deep learning frameworks: The simplest one is to mask the parts of the filter kernel that are concerned with future input, by setting them to zero at each SGD update, but that is quite expensive as about half of the multiplications and additions go to waste. A more efficient way is to shift and pad the signal by the kernel size and then undo the shifting (which relies on the translation-equivariance property of convolution).</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/08/18/%E6%97%B6%E9%97%B4%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C(TCN)%EF%BC%9A%E7%BB%93%E6%9E%84+pytorch%E4%BB%A3%E7%A0%81/">
                时间卷积网络(TCN)：结构+pytorch代码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-08-18</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="时间卷积网络-TCN-：结构-pytorch代码"><a href="#时间卷积网络-TCN-：结构-pytorch代码" class="headerlink" title="时间卷积网络(TCN)：结构+pytorch代码"></a>时间卷积网络(TCN)：结构+pytorch代码</h1><h2 id="TCN"><a href="#TCN" class="headerlink" title="TCN"></a>TCN</h2><p>  TCN(Temporal Convolutional Network)是由Shaojie Bai et al.提出的，paper地址：<a href="https://arxiv.org/pdf/1803.01271.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1803.01271.pdf</a></p>
<p>  想要了解TCN，最好先知道<a href="https://blog.csdn.net/Leon_winter/article/details/87728755" target="_blank" rel="noopener">CNN</a>和<a href="https://blog.csdn.net/Leon_winter/article/details/89089458" target="_blank" rel="noopener">RNN</a>。</p>
<p>  以往一旦提起sequence，或者存在时间序列的数据，想到的神经网络模型就是RNN及其变种LSTM、GRU等。在上面论文提到，很多工作表明，在RNN这个框架中，很难再找到新的模型，其效果可以在很多任务中超越LSTM，但是跳出RNN这个框架，paper作者展示了利用CNN衍生出的TCN结构就很容易在很多任务中取得超过LSTM、GRU的效果。当然paper作者也表示，TCN并不指代一种模型，更像是一种类似RNN的框架，paper作者渴望抛砖引玉，让更多人来探索挖掘这个框架的能力。</p>
<h2 id="TCN结构"><a href="#TCN结构" class="headerlink" title="TCN结构"></a>TCN结构</h2><p>  TCN的设计十分巧妙，同ConvLSTM不同的是，ConvLSTM通过引入卷积操作，让LSTM网络可以处理图像信息，其卷积只对一个时间的输入图像进行操作，TCN则直接利用卷积强大的特性，跨时间步提取特征。</p>
<p>  TCN结构很像Wavenet，paper作者也表示确实借鉴了Wavenet的结构，TCN的结构在paper中表示如下，这是一个kernel size=3,dilations=[1,2,4]kernel~size = 3, dilations = [1, 2, 4]<em>kernel</em> <em>size</em>=3,<em>dilations</em>=[1,2,4]的TCN。</p>
<p><img src="https://img-blog.csdnimg.cn/20190829100025261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlb25fd2ludGVy,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>下图展示了更直接的TCN结构，kernel size=2,dilations=[1,2,4,8]kernel~size = 2, dilations = [1, 2, 4, 8]<em>kernel</em> <em>size</em>=2,<em>dilations</em>=[1,2,4,8]</p>
<p><img src="https://img-blog.csdnimg.cn/20190829093440798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlb25fd2ludGVy,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>kernel size等于2，即每一层的输入，是上一层的两个时刻的输出；dilations = [1, 2, 4, 8]，即每一层的输入的时间间隔有多大，dilation=4，即上一层每前推4个时间步的输出，作为这一层的输入，直到取够kernal size个输入。</p>
<p>  TCN要实现RNN的类似功能，需要解决两个问题，</p>
<ol>
<li>TCN如何像RNN那样，输入多长的时间步，输出时间步也是同样长度，或者说，每个时间的输入都有对应的输出；</li>
<li>如何保证历史数据不漏接(no leakage)。</li>
</ol>
<p>  为了解决上面的两个问题，paper作者分别引入了1-D FCN和因果卷积(Causal Convolutions)，可以说<br>TCN=1D FCN+Causal ConvolutionsTCN = 1D<del>FCN + Causal</del>Convolutions<em>TCN</em>=1<em>D</em> <em>FCN</em>+<em>Causal</em> <em>Convolutions</em></p>
<h3 id="1-D-FCN的结构"><a href="#1-D-FCN的结构" class="headerlink" title="1-D FCN的结构"></a>1-D FCN的结构</h3><p>  为了解决第一个问题，TCN利用了1-D FCN的结构，每一个隐层的输入输出的时间长度都相同，维持相同的时间步，具体来看，第一隐层不管kernel size和dilation为多少，输入若是n个时间步，输出也是n个时间步，同样第二隐层，第三隐层。。。的输入输出时间步长度都是n，这点和RNN就很像，不管在哪一层，每个时间步的输入都会有对应的输出。</p>
<p>  对于第一个时间步，没有任何历史的信息，TCN认为其历史数据全是0 (其实就是卷积操作的padding，这一点最好结合下面的代码理解)，同时paper作者通过实验发现，TCN保留长远历史信息的能力较LSTM更强。</p>
<h3 id="因果卷积-Causal-Convolutions"><a href="#因果卷积-Causal-Convolutions" class="headerlink" title="因果卷积(Causal Convolutions)"></a>因果卷积(Causal Convolutions)</h3><p>  为了解决第二个问题，TCN利用因果卷积(Causal Convolutions)，所谓因果，也就是对于输出t时刻的数据yty_{t}<em>yt</em>，其输入只可能是t以及t以前的时刻，即x0…xtx_{0}\dots x_{t}<em>x</em>0…<em>xt</em>，其结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2019082909091041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlb25fd2ludGVy,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>不难发现，这样的卷积连接好像和最上面的TCN结构图不太一样，理论上利用因果卷积是可以搭建TCN，但是如果我们的输出和之前的1000个时间点都存在联系，要获取这种联系，因果卷积构成的TCN深度就是1000-1，如果和历史的10000个时间点有联系，那么深度就是10000-1…，那样TCN就太深了。</p>
<h3 id="膨胀因果卷积-Dilated-Causal-Convolutions"><a href="#膨胀因果卷积-Dilated-Causal-Convolutions" class="headerlink" title="膨胀因果卷积(Dilated Causal Convolutions)"></a>膨胀因果卷积(Dilated Causal Convolutions)</h3><p>  为了有效的应对长历史信息这一问题，paper作者利用了膨胀因果卷积(Dilated Causal Convolutions)，还是具有因果性，只不过引入了膨胀因子(dilation factor) dd<em>d</em>，对于kernel size=2,dilations=[1,2,4,8]kernel~size = 2, dilations = [1, 2, 4, 8]<em>kernel</em> <em>size</em>=2,<em>dilations</em>=[1,2,4,8]的TCN，其结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190829091941330.gif" alt="img"></p>
<p>一般膨胀系数是2的指数次方，即1，2，4，8，16，32…</p>
<h3 id="膨胀非因果卷积-Dilated-Non-Causal-Convolutions"><a href="#膨胀非因果卷积-Dilated-Non-Causal-Convolutions" class="headerlink" title="膨胀非因果卷积(Dilated Non-Causal Convolutions)"></a>膨胀非因果卷积(Dilated Non-Causal Convolutions)</h3><p>  LSTM是可以双边输入的，输入不仅利用历史信息，也利用了未来信息，TCN也能做到类似的实现，利用膨胀非因果卷积(Dilated Non-Causal Convolutions)，下图展示了kernel size=3,dilations=[1,2,4,8]kernel~size = 3, dilations = [1, 2, 4, 8]<em>kernel</em> <em>size</em>=3,<em>dilations</em>=[1,2,4,8]的膨胀非因果卷积构成的TCN：</p>
<p><img src="https://img-blog.csdnimg.cn/20190829092541148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlb25fd2ludGVy,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="残差块结构"><a href="#残差块结构" class="headerlink" title="残差块结构"></a>残差块结构</h3><p>  同时，就算我们使用了膨胀因果卷积，有时模型可能仍然很深，较深的网络结构可能会引起梯度消失等问题，为了应对这种情况，paper作者利用了一种类似于ResNet中的残差块的结构，这样设计的TCN结构更加的具有泛化能力(generic)。</p>
<p><img src="https://img-blog.csdnimg.cn/20190829101302335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlb25fd2ludGVy,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>o=Activation(x+F(x))o=Activation(x+F(x))<em>o</em>=<em>Activation</em>(<em>x</em>+<em>F</em>(<em>x</em>))</p>
<p>可以看出来，残差结构替代了TCN层与层之间的简单连接，由于xx<em>x</em>和F(x)F(x)<em>F</em>(<em>x</em>)之间的通道数可能不一样，所以这里设计了一个1×1 Conv1\times1~Conv1×1 <em>Conv<em>来对x做一个简单的变换，使得变换后的xx</em>x<em>与F(x)F(x)</em>F</em>(<em>x</em>)可以相加。其实这里的图都有一定的欺骗性，每一层每个时刻只有一个网格并不代表这一时刻的通道数等于1。</p>
<h2 id="pytorch代码讲解"><a href="#pytorch代码讲解" class="headerlink" title="pytorch代码讲解"></a>pytorch代码讲解</h2><p>  paper给的代码是pytorch版本的，<a href="https://github.com/locuslab/TCN" target="_blank" rel="noopener">获取点这里</a>，其中TCN模型部分的代码如下，重难点部分给出了注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">from torch.nn.utils import weight_norm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Chomp1d(nn.Module):</span><br><span class="line">    def __init__(self, chomp_size):</span><br><span class="line">        super(Chomp1d, self).__init__()</span><br><span class="line">        self.chomp_size &#x3D; chomp_size</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        其实这就是一个裁剪的模块，裁剪多出来的padding</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return x[:, :, :-self.chomp_size].contiguous()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TemporalBlock(nn.Module):</span><br><span class="line">    def __init__(self, n_inputs, n_outputs, kernel_size, stride, dilation, padding, dropout&#x3D;0.2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        相当于一个Residual block</span><br><span class="line"></span><br><span class="line">        :param n_inputs: int, 输入通道数</span><br><span class="line">        :param n_outputs: int, 输出通道数</span><br><span class="line">        :param kernel_size: int, 卷积核尺寸</span><br><span class="line">        :param stride: int, 步长，一般为1</span><br><span class="line">        :param dilation: int, 膨胀系数</span><br><span class="line">        :param padding: int, 填充系数</span><br><span class="line">        :param dropout: float, dropout比率</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(TemporalBlock, self).__init__()</span><br><span class="line">        self.conv1 &#x3D; weight_norm(nn.Conv1d(n_inputs, n_outputs, kernel_size,</span><br><span class="line">                                           stride&#x3D;stride, padding&#x3D;padding, dilation&#x3D;dilation))</span><br><span class="line">        # 经过conv1，输出的size其实是(Batch, input_channel, seq_len + padding)</span><br><span class="line">        self.chomp1 &#x3D; Chomp1d(padding)  # 裁剪掉多出来的padding部分，维持输出时间步为seq_len</span><br><span class="line">        self.relu1 &#x3D; nn.ReLU()</span><br><span class="line">        self.dropout1 &#x3D; nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">        self.conv2 &#x3D; weight_norm(nn.Conv1d(n_outputs, n_outputs, kernel_size,</span><br><span class="line">                                           stride&#x3D;stride, padding&#x3D;padding, dilation&#x3D;dilation))</span><br><span class="line">        self.chomp2 &#x3D; Chomp1d(padding)  #  裁剪掉多出来的padding部分，维持输出时间步为seq_len</span><br><span class="line">        self.relu2 &#x3D; nn.ReLU()</span><br><span class="line">        self.dropout2 &#x3D; nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">        self.net &#x3D; nn.Sequential(self.conv1, self.chomp1, self.relu1, self.dropout1,</span><br><span class="line">                                 self.conv2, self.chomp2, self.relu2, self.dropout2)</span><br><span class="line">        self.downsample &#x3D; nn.Conv1d(n_inputs, n_outputs, 1) if n_inputs !&#x3D; n_outputs else None</span><br><span class="line">        self.relu &#x3D; nn.ReLU()</span><br><span class="line">        self.init_weights()</span><br><span class="line"></span><br><span class="line">    def init_weights(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        参数初始化</span><br><span class="line"></span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.conv1.weight.data.normal_(0, 0.01)</span><br><span class="line">        self.conv2.weight.data.normal_(0, 0.01)</span><br><span class="line">        if self.downsample is not None:</span><br><span class="line">            self.downsample.weight.data.normal_(0, 0.01)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param x: size of (Batch, input_channel, seq_len)</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        out &#x3D; self.net(x)</span><br><span class="line">        res &#x3D; x if self.downsample is None else self.downsample(x)</span><br><span class="line">        return self.relu(out + res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TemporalConvNet(nn.Module):</span><br><span class="line">    def __init__(self, num_inputs, num_channels, kernel_size&#x3D;2, dropout&#x3D;0.2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        TCN，目前paper给出的TCN结构很好的支持每个时刻为一个数的情况，即sequence结构，</span><br><span class="line">        对于每个时刻为一个向量这种一维结构，勉强可以把向量拆成若干该时刻的输入通道，</span><br><span class="line">        对于每个时刻为一个矩阵或更高维图像的情况，就不太好办。</span><br><span class="line"></span><br><span class="line">        :param num_inputs: int， 输入通道数</span><br><span class="line">        :param num_channels: list，每层的hidden_channel数，例如[25,25,25,25]表示有4个隐层，每层hidden_channel数为25</span><br><span class="line">        :param kernel_size: int, 卷积核尺寸</span><br><span class="line">        :param dropout: float, drop_out比率</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(TemporalConvNet, self).__init__()</span><br><span class="line">        layers &#x3D; []</span><br><span class="line">        num_levels &#x3D; len(num_channels)</span><br><span class="line">        for i in range(num_levels):</span><br><span class="line">            dilation_size &#x3D; 2  i   # 膨胀系数：1，2，4，8……</span><br><span class="line">            in_channels &#x3D; num_inputs if i &#x3D;&#x3D; 0 else num_channels[i-1]  # 确定每一层的输入通道数</span><br><span class="line">            out_channels &#x3D; num_channels[i]  # 确定每一层的输出通道数</span><br><span class="line">            layers +&#x3D; [TemporalBlock(in_channels, out_channels, kernel_size, stride&#x3D;1, dilation&#x3D;dilation_size,</span><br><span class="line">                                     padding&#x3D;(kernel_size-1) * dilation_size, dropout&#x3D;dropout)]</span><br><span class="line"></span><br><span class="line">        self.network &#x3D; nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        输入x的结构不同于RNN，一般RNN的size为(Batch, seq_len, channels)或者(seq_len, Batch, channels)，</span><br><span class="line">        这里把seq_len放在channels后面，把所有时间步的数据拼起来，当做Conv1d的输入尺寸，实现卷积跨时间步的操作，</span><br><span class="line">        很巧妙的设计。</span><br><span class="line"></span><br><span class="line">        :param x: size of (Batch, input_channel, seq_len)</span><br><span class="line">        :return: size of (Batch, output_channel, seq_len)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.network(x)</span><br><span class="line">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105</span><br></pre></td></tr></table></figure>

<p>参考资料：<br>TCN: <a href="https://arxiv.org/pdf/1803.01271.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1803.01271.pdf</a></p>
<p>因果卷积（causal）与扩展卷积（dilated）：<a href="https://blog.csdn.net/tonygsw/article/details/81280364" target="_blank" rel="noopener">https://blog.csdn.net/tonygsw/article/details/81280364</a></p>
<p>philipperemy/keras-tcn<br>：<a href="https://github.com/philipperemy/keras-tcn#why-temporal-convolutional-network" target="_blank" rel="noopener">https://github.com/philipperemy/keras-tcn#why-temporal-convolutional-network</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/07/19/%E3%80%90%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E3%80%91Stacked%20Hourglass%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">
                【人体姿态】Stacked Hourglass算法详解
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="【人体姿态】Stacked-Hourglass算法详解"><a href="#【人体姿态】Stacked-Hourglass算法详解" class="headerlink" title="【人体姿态】Stacked Hourglass算法详解"></a>【人体姿态】Stacked Hourglass算法详解</h1><p>Newell, Alejandro, Kaiyu Yang, and Jia Deng. “Stacked hourglass networks for human pose estimation.” arXiv preprint arXiv:1603.06937 (2016).</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文使用全卷积网络解决人体姿态分析问题，截至2016年5月，在MPII姿态分析竞赛中暂列榜首，PCKh（误差小于一半头高的样本比例）达到89.4%。与排名第二的CPM(Convolutiona Pose Machine)1方法相比，思路更明晰，网络更简洁。<br>作者给出了基于Torch的代码和模型。单显卡，测试时间约130ms，使用cudnn4的训练时间约3天，比CPM方法有显著优势。</p>
<p>本篇博客结合源码，从无到有介绍Stacked Hourglass的搭建思路，之后介绍代价函数与训练过程，最后总结值得学习的思想。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>本篇论文的源码体现了模块-&gt;子网络-&gt;完整网络的设计思想。</p>
<h3 id="Residual模块"><a href="#Residual模块" class="headerlink" title="Residual模块"></a>Residual模块</h3><blockquote>
<p>先来复习一下卷积层和pooling层的属性：<br>核尺寸（kernel）决定了特征的尺度；步长（stride）决定了降采样的比例；算子的通道数（channel）决定了输出数据的层数/深度</p>
</blockquote>
<p>本文使用的初级模块称为Residual Module，得名于其中的旁路相加结构（在这篇论文中2称为residual learning）</p>
<p>第一行为卷积路，由三个核尺度不同的卷积层（白色）串联而成，间插有Batch Normalization（浅蓝）和ReLU（浅紫）；<br>第二行为跳级路，只包含一个核尺度为1的卷积层；如果跳级路的输入输出通道数相同，则这一路为单位映射。<br>所有卷积层的步长为1，pading为1，不改变数据尺寸，只对数据深度（channel）进行变更。<br>Residual Module由两个参数控制：输入深度M和输出深度N。可以对任意尺寸图像操作。</p>
<blockquote>
<p>设计思想：channel大的卷积，kernel要小；kernel大的卷积，channel要小。<br>其实许多网络已经隐含了模块化的思想，例如AlexNet中重复出现的conv+relu+pool模式。</p>
</blockquote>
<p>作用：Residual模块提取了较高层次的特征（卷积路），同时保留了原有层次的信息（跳级路）。不改变数据尺寸，只改变数据深度。可以把它看做一个保尺寸的高级“卷积”层。</p>
<h2 id="Hourglass子网络"><a href="#Hourglass子网络" class="headerlink" title="Hourglass子网络"></a>Hourglass子网络</h2><p>Hourglass是本文的核心部件，由Residual模块组成。根据阶数不同，有不同的复杂程度。</p>
<h3 id="一阶Hourglass"><a href="#一阶Hourglass" class="headerlink" title="一阶Hourglass"></a>一阶Hourglass</h3><p>上下两个半路都包含若干Residual模块（浅绿），逐步提取更深层次特征。但上半路在原尺度进行，下半路经历了先降采样（红色/2）再升采样（红色*2）的过程。<br>降采样使用max pooling，升采样使用最近邻插值。</p>
<p>另一种进行升采样的方法是反卷积层（Deconv），可以参看这篇解决分割问题的Fully Convolutional论文。</p>
<h3 id="二阶Hourglass"><a href="#二阶Hourglass" class="headerlink" title="二阶Hourglass"></a>二阶Hourglass</h3><p>把一阶模块的灰框内部分替换成一个一阶Hourglass（输入通道256，输出通道N），得到二阶Hourglass：</p>
<p>两个层次的下半路组成了一条两次降采样，再两次升采样的过程。两个层次的下半路则分别在原始尺寸（OriSize）和1/2原始尺寸，辅助升采样。</p>
<h3 id="四阶Hourglass"><a href="#四阶Hourglass" class="headerlink" title="四阶Hourglass"></a>四阶Hourglass</h3><p>本文使用的是四阶Hourglass：</p>
<p>每次降采样之前，分出上半路保留原尺度信息；<br>每次升采样之后，和上一个尺度的数据相加；<br>两次降采样之间，使用三个Residual模块提取特征；<br>两次相加之间，使用一个Residual模块提取特征。</p>
<p>由于考虑了各个尺度的特征，本文不需要像CPM3方法一样独立地在图像金字塔上多次运行，速度更快。</p>
<p>作用：n阶Hourglass子网络提取了从原始尺度到1/2n1/2n尺度的特征。不改变数据尺寸，只改变数据深度。</p>
<h2 id="完整网络结构"><a href="#完整网络结构" class="headerlink" title="完整网络结构"></a>完整网络结构</h2><h3 id="一级网络"><a href="#一级网络" class="headerlink" title="一级网络"></a>一级网络</h3><p>以一个Hourglass（深绿色）为中心，可以从彩色图像预测K个人体部件的响应图：</p>
<p>原始图像经过一次降采样（橙色），输入到Hourglass子网络中。Hourglass的输出结果经过两个线性模块（灰色），得到最终响应图。期间使用Residual模块（浅绿）和卷积层（白色）逐步提取特征。</p>
<h3 id="二级网络"><a href="#二级网络" class="headerlink" title="二级网络"></a>二级网络</h3><p>本文使用的完整网络包含两个Hourglass：</p>
<p>对比上图，二级网络重复了一级网络的后半结构。第二个Hourglass的输入包含三路：</p>
<ul>
<li>第一个Hourglass的输入数据</li>
<li>第一个Hourglass的输出数据</li>
<li>第一级预测结果<br>这三路数据通过串接（concat）和相加进行融合，它们的尺度不同，体现了当下流行的跳级结构思想。</li>
</ul>
<h2 id="代价函数与训练"><a href="#代价函数与训练" class="headerlink" title="代价函数与训练"></a>代价函数与训练</h2><p>对于H×W×3H×W×3的输入图像，每一个hourglass级都会生成一个H/2×W/2×KH/2×W/2×K的响应图。对于每个响应图，都比较其与真值的误差作为代价。这种做法和CPM方法类似，都体现了中继监督(intermediate supervision)的思想。</p>
<blockquote>
<p>在源码中，整个网络的输出结果包含每个级别的响应图，但在测试中只使用最后一级结果。这是因为torch的代价函数只能绑定在输出数据上。</p>
</blockquote>
<p>使用cudnn4，在单个TitanX GPU(12G显存)上训练MPII数据，本文方法需要3天时间。</p>
<p>总结<br>本论文中值得学习的思想如下：</p>
<ul>
<li>使用模块进行网络设计</li>
<li>先降采样，再升采样的全卷积结构</li>
<li>跳级结构辅助升采样</li>
<li>中继监督训练</li>
</ul>
<p>Wei, Shih-En, et al. “Convolutional Pose Machines.” CVPR, 2016 ↩<br>He, Kaiming, et al. “Deep Residual Learning for Image Recognition.” arXiv preprint arXiv:1512.03385 (2015). ↩<br>Wei, Shih-En, et al. “Convolutional Pose Machines.” CVPR, 2016 ↩<br>————————————————<br>版权声明：本文为CSDN博主「shenxiaolu1984」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51428392" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaolu1984/article/details/51428392</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/07/19/pytorch_resnet/">
                pytorch_resnet
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>PyTorch框架中有一个非常重要且好用的包：torchvision，该包主要由3个子包组成，分别是：torchvision.datasets、torchvision.models、torchvision.transforms。这3个子包的具体介绍可以参考官网：<a href="http://pytorch.org/docs/master/torchvision/index.html。具体代码可以参考github：https://github.com/pytorch/vision/tree/master/torchvision。" target="_blank" rel="noopener">http://pytorch.org/docs/master/torchvision/index.html。具体代码可以参考github：https://github.com/pytorch/vision/tree/master/torchvision。</a></p>
<p>这篇博客介绍torchvision.models。torchvision.models这个包中包含alexnet、densenet、inception、resnet、squeezenet、vgg等常用的网络结构，并且提供了预训练模型，可以通过简单调用来读取网络结构和预训练模型。</p>
<p>使用例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">model = torchvision.models.resnet50(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p>这样就导入了resnet50的预训练模型了。如果只需要网络结构，不需要用预训练模型的参数来初始化，那么就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.resnet50(pretrained=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>如果要导入densenet模型也是同样的道理，比如导入densenet169，且不需要是预训练的模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.densenet169(pretrained=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>由于pretrained参数默认是False，所以等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.densenet169()</span><br></pre></td></tr></table></figure>
<p>不过为了代码清晰，最好还是加上参数赋值。</p>
<p>接下来以导入resnet50为例介绍具体导入模型时候的源码。运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = torchvision.models.resnet50(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>的时候，是通过models包下的resnet.py脚本进行的，源码如下：</p>
<p>首先是导入必要的库，其中model_zoo是和导入预训练模型相关的包，另外all变量定义了可以从外部import的函数名或类名。这也是前面为什么可以用torchvision.models.resnet50()来调用的原因。model_urls这个字典是预训练模型的下载地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch.utils.model_zoo <span class="keyword">as</span> model_zoo</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'ResNet'</span>, <span class="string">'resnet18'</span>, <span class="string">'resnet34'</span>, <span class="string">'resnet50'</span>, <span class="string">'resnet101'</span>,</span><br><span class="line">           <span class="string">'resnet152'</span>]</span><br><span class="line"></span><br><span class="line">model_urls = &#123;</span><br><span class="line">    <span class="string">'resnet18'</span>: <span class="string">'https://download.pytorch.org/models/resnet18-5c106cde.pth'</span>,</span><br><span class="line">    <span class="string">'resnet34'</span>: <span class="string">'https://download.pytorch.org/models/resnet34-333f7ec4.pth'</span>,</span><br><span class="line">    <span class="string">'resnet50'</span>: <span class="string">'https://download.pytorch.org/models/resnet50-19c8e357.pth'</span>,</span><br><span class="line">    <span class="string">'resnet101'</span>: <span class="string">'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth'</span>,</span><br><span class="line">    <span class="string">'resnet152'</span>: <span class="string">'https://download.pytorch.org/models/resnet152-b121ed2d.pth'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是resnet50这个函数了，参数pretrained默认是False。首先model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)是构建网络结构，Bottleneck是另外一个构建bottleneck的类，在ResNet网络结构的构建中有很多重复的子结构，这些子结构就是通过Bottleneck类来构建的，后面会介绍。然后如果参数pretrained是True，那么就会通过model_zoo.py中的load_url函数根据model_urls字典下载或导入相应的预训练模型。最后通过调用model的load_state_dict方法用预训练的模型参数来初始化你构建的网络结构，这个方法就是PyTorch中通用的用一个模型的参数初始化另一个模型的层的操作。load_state_dict方法还有一个重要的参数是strict，该参数默认是True，表示预训练模型的层和你的网络结构层严格对应相等（比如层名和维度）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet50</span><span class="params">(pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet50'</span>]))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>其他resnet18、resnet101等函数和resnet50基本类似，差别主要是在：1、构建网络结构的时候block的参数不一样，比如resnet18中是[2, 2, 2, 2]，resnet101中是[3, 4, 23, 3]。2、调用的block类不一样，比如在resnet50、resnet101、resnet152中调用的是Bottleneck类，而在resnet18和resnet34中调用的是BasicBlock类，这两个类的区别主要是在residual结果中卷积层的数量不同，这个是和网络结构相关的，后面会详细介绍。3、如果下载预训练模型的话，model_urls字典的键不一样，对应不同的预训练模型。因此接下来分别看看如何构建网络结构和如何导入预训练模型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet18</span><span class="params">(pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-18 model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(BasicBlock, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet18'</span>]))</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet101</span><span class="params">(pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-101 model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet101'</span>]))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>构建ResNet网络是通过ResNet这个类进行的。首先还是继承PyTorch中网络的基类：torch.nn.Module，其次主要的是重写初始化<strong>init</strong>和forward方法。在初始化<strong>init</strong>中主要是定义一些层的参数。forward方法中主要是定义数据在层之间的流动顺序，也就是层的连接顺序。另外还可以在类中定义其他私有方法用来模块化一些操作，比如这里的_make_layer方法是用来构建ResNet网络中的4个blocks。_make_layer方法的第一个输入block是Bottleneck或BasicBlock类，第二个输入是该blocks的输出channel，第三个输入是每个blocks中包含多少个residual子结构，因此layers这个列表就是前面resnet50的[3, 4, 6, 3]。<br>_make_layer方法中比较重要的两行代码是：1、layers.append(block(self.inplanes, planes, stride, downsample))，该部分是将每个blocks的第一个residual结构保存在layers列表中。2、 for i in range(1, blocks): layers.append(block(self.inplanes, planes))，该部分是将每个blocks的剩下residual 结构保存在layers列表中，这样就完成了一个blocks的构造。这两行代码中都是通过Bottleneck这个类来完成每个residual的构建，接下来介绍Bottleneck类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, block, layers, num_classes=<span class="number">1000</span>)</span>:</span></span><br><span class="line">        self.inplanes = <span class="number">64</span></span><br><span class="line">        super(ResNet, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>,padding=<span class="number">3</span>,bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.layer1 = self._make_layer(block, <span class="number">64</span>, layers[<span class="number">0</span>])</span><br><span class="line">        self.layer2 = self._make_layer(block, <span class="number">128</span>, layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(block, <span class="number">256</span>, layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(block, <span class="number">512</span>, layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * block.expansion, num_classes)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> isinstance(m, nn.Conv2d):</span><br><span class="line">                n = m.kernel_size[<span class="number">0</span>] * m.kernel_size[<span class="number">1</span>] * m.out_channels</span><br><span class="line">                m.weight.data.normal_(<span class="number">0</span>, math.sqrt(<span class="number">2.</span> / n))</span><br><span class="line">            <span class="keyword">elif</span> isinstance(m, nn.BatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_layer</span><span class="params">(self, block, planes, blocks, stride=<span class="number">1</span>)</span>:</span></span><br><span class="line">        downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> self.inplanes != planes * block.expansion:</span><br><span class="line">            downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                          kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion),</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(self.inplanes, planes, stride, downsample))</span><br><span class="line">        self.inplanes = planes * block.expansion</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, blocks):</span><br><span class="line">            layers.append(block(self.inplanes, planes))</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.maxpool(x)</span><br><span class="line">    </span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line">    </span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<p>从前面的ResNet类可以看出，在构造ResNet网络的时候，最重要的是Bottleneck这个类，因为ResNet是由residual结构组成的，而Bottleneck类就是完成residual结构的构建。同样Bottlenect还是继承了torch.nn.Module类，且重写了<strong>init</strong>和forward方法。从forward方法可以看出，bottleneck就是我们熟悉的3个主要的卷积层、BN层和激活层，最后的out += residual就是element-wise add的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * <span class="number">4</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * <span class="number">4</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line">    </span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">    </span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">    </span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">    </span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">BasicBlock类和Bottleneck类类似，前者主要是用来构建ResNet18和ResNet34网络，因为这两个网络的residual结构只包含两个卷积层，没有Bottleneck类中的bottleneck概念。因此在该类中，第一个卷积层采用的是kernel_size=<span class="number">3</span>的卷积，如conv3x3函数所示。</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv3x3</span><span class="params">(in_planes, out_planes, stride=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""3x3 convolution with padding"""</span></span><br><span class="line">    <span class="keyword">return</span> nn.Conv2d(in_planes, out_planes, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                     padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicBlock</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None)</span>:</span></span><br><span class="line">        super(BasicBlock, self).__init__()</span><br><span class="line">        self.conv1 = conv3x3(inplanes, planes, stride)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.conv2 = conv3x3(planes, planes)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line">    </span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">    </span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">    </span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<p>介绍完如何构建网络，接下来就是如何获取预训练模型。前面提到这一行代码：if pretrained: model.load_state_dict(model_zoo.load_url(model_urls[‘resnet50’]))，主要就是通过model_zoo.py中的load_url函数根据model_urls字典导入相应的预训练模型，models_zoo.py脚本的github地址：<a href="https://github.com/pytorch/pytorch/blob/master/torch/utils/model_zoo.py。" target="_blank" rel="noopener">https://github.com/pytorch/pytorch/blob/master/torch/utils/model_zoo.py。</a><br>load_url函数源码如下。首先model_dir是下载下来的模型的保存地址，如果没有指定的话就会保存在项目的.torch目录下，最好指定。cached_file是保存模型的路径加上模型名称。接下来的 if not os.path.exists(cached_file)语句用来判断是否指定目录下已经存在要下载模型，如果已经存在，就直接调用torch.load接口导入模型，如果不存在，则从网上下载，下载是通过_download_url_to_file(url, cached_file, hash_prefix, progress=progress)进行的，不再细讲。重点在于模型导入是通过torch.load()接口来进行的，不管你的模型是从网上下载的还是本地已有的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, model_dir=None, map_location=None, progress=True)</span>:</span></span><br><span class="line">    <span class="string">r"""Loads the Torch serialized object at the given URL.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the object is already present in `model_dir`, it's deserialized and</span></span><br><span class="line"><span class="string">    returned. The filename part of the URL should follow the naming convention</span></span><br><span class="line"><span class="string">    ``filename-&lt;sha256&gt;.ext`` where ``&lt;sha256&gt;`` is the first eight or more</span></span><br><span class="line"><span class="string">    digits of the SHA256 hash of the contents of the file. The hash is used to</span></span><br><span class="line"><span class="string">    ensure unique names and to verify the contents of the file.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The default value of `model_dir` is ``$TORCH_HOME/models`` where</span></span><br><span class="line"><span class="string">    ``$TORCH_HOME`` defaults to ``~/.torch``. The default directory can be</span></span><br><span class="line"><span class="string">    overriden with the ``$TORCH_MODEL_ZOO`` environment variable.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url (string): URL of the object to download</span></span><br><span class="line"><span class="string">        model_dir (string, optional): directory in which to save the object</span></span><br><span class="line"><span class="string">        map_location (optional): a function or a dict specifying how to remap storage locations (see torch.load)</span></span><br><span class="line"><span class="string">        progress (bool, optional): whether or not to display a progress bar to stderr</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; state_dict = torch.utils.model_zoo.load_url('https://s3.amazonaws.com/pytorch/models/resnet18-5c106cde.pth')</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> model_dir <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        torch_home = os.path.expanduser(os.getenv(<span class="string">'TORCH_HOME'</span>, <span class="string">'~/.torch'</span>))</span><br><span class="line">        model_dir = os.getenv(<span class="string">'TORCH_MODEL_ZOO'</span>, os.path.join(torch_home, <span class="string">'models'</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_dir):</span><br><span class="line">        os.makedirs(model_dir)</span><br><span class="line">    parts = urlparse(url)</span><br><span class="line">    filename = os.path.basename(parts.path)</span><br><span class="line">    cached_file = os.path.join(model_dir, filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(cached_file):</span><br><span class="line">        sys.stderr.write(<span class="string">'Downloading: "&#123;&#125;" to &#123;&#125;\n'</span>.format(url, cached_file))</span><br><span class="line">        hash_prefix = HASH_REGEX.search(filename).group(<span class="number">1</span>)</span><br><span class="line">        _download_url_to_file(url, cached_file, hash_prefix, progress=progress)</span><br><span class="line">    <span class="keyword">return</span> torch.load(cached_file, map_location=map_location)</span><br></pre></td></tr></table></figure>
<p>————————————————<br>版权声明：本文为CSDN博主「AI之路」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u014380165/java/article/details/79119664" target="_blank" rel="noopener">https://blog.csdn.net/u014380165/java/article/details/79119664</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/07/11/VAE/">
                VAE
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-11</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="VAEs简介"><a href="#VAEs简介" class="headerlink" title="VAEs简介"></a>VAEs简介</h2><p>变分自编码器（Variational auto-encoder，VAE）是一类重要的生成模型（generative<br>model），它于2013年由Diederik P.Kingma和Max Welling提出[1]。2016年Carl<br>Doersch写了一篇VAEs的tutorial[2]，对VAEs做了更详细的介绍，比文献[1]更易懂。这篇读书笔记基于文献[1]。</p>
<p>除了VAEs，还有一类重要的生成模型GANs（对GANs感兴趣可以去我的微信公众号看介绍文章：学术兴趣小组）。</p>
<p>我们来看一下VAE是怎样设计的。</p>
<p><img src="/2020/07/11/VAE/v2-c2acba45269364fcfd460d37848f441d_b.jpg" alt></p>
<p>上图是VAE的图模型。我们能观测到的数据是  $\displaystyle \text{x}$  ，而  $\displaystyle \text{x}$<br>由隐变量  $\displaystyle \text{z}$  产生，由  $\displaystyle \text{z}\rightarrow<br>\text{x}$  是生成模型  $\displaystyle p_{\theta}(\text{x}|\text{z})$  ，从自编码器（auto-<br>encoder）的角度来看，就是解码器；而由  $\displaystyle \text{x}\rightarrow \text{z}$<br>是识别模型（recognition model）  $\displaystyle q_{\phi}(\text{z}|\text{x})$<br>，类似于自编码器的编码器。</p>
<p>VAEs现在广泛地用于生成图像，当生成模型  $\displaystyle p_{\theta}(\text{x}|\text{z})$<br>训练好了以后，我们就可以用它来生成图像了。与GANs不同的是，我们是知道图像的密度函数（PDF）的（或者说，是我们设定的），而GANs我们并不知道图像的分布。</p>
<h2 id="VAEs模型的理论推导"><a href="#VAEs模型的理论推导" class="headerlink" title="VAEs模型的理论推导"></a>VAEs模型的理论推导</h2><p>以下的推导参考了文献[1]和[3]，文献[3]是变分推理的课件。</p>
<p>首先，假定所有的数据都是独立同分布的（i.i.d），两个观测不会相互影响。我们要对生成模型  $\displaystyle<br>p_{\theta}(\text{x}|\text{z})$  做参数估计，利用对数最大似然法，就是要最大化下面的对数似然函数：</p>
<p>$\displaystyle \log<br>p_{\theta}(\text{x}^{(1)},\text{x}^{(2)},\cdots,\text{x}^{(N)})=\sum_{i=1}^N<br>\log p_{\theta}(\text{x}^{(i)})$</p>
<p>VAEs用识别模型  $\displaystyle q_{\phi}(\text{z}|\text{x}^{(i)})$  去逼近真实的后验概率<br>$\displaystyle p_{\theta}(\text{z}|\text{x}^{(i)})$  ，衡量两个分布的相似程度，我们一般采用KL散度，即</p>
<p>$\displaystyle \begin{align}<br>KL(q_{\phi}(\text{z}|\text{x}^{(i)})||p_{\theta}(\text{z}|\text{x}^{(i)}))&amp;=\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})}<br>\log<br>\frac{q_{\phi}(\text{z}|\text{x}^{(i)})}{p_{\theta}(\text{z}|\text{x}^{(i)})}\<br>&amp;=\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>\frac{q_{\phi}(\text{z}|\text{x}^{(i)})p_{\theta}(\text{x}^{(i)})}{p_{\theta}(\text{z}|\text{x}^{(i)})p_{\theta}(\text{x}^{(i)})}\<br>&amp;=\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>\frac{q_{\phi}(\text{z}|\text{x}^{(i)})}{p_{\theta}(\text{z},\text{x}^{(i)})}+\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})}<br>\log p_{\theta}(\text{x}^{(i)})\<br>&amp;=\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>\frac{q_{\phi}(\text{z}|\text{x}^{(i)})}{p_{\theta}(\text{z},\text{x}^{(i)})}+\log<br>p_{\theta}(\text{x}^{(i)}) \end{align}$</p>
<p>于是</p>
<p>$\displaystyle \log<br>p_{\theta}(\text{x}^{(i)})=KL(q_{\phi}(\text{z}|\text{x}^{(i)}),<br>p_{\theta}(\text{z}|\text{x}^{(i)}))+\mathcal{L}(\theta,\phi;\text{x}^{(i)})$</p>
<p>其中，</p>
<p>$\displaystyle \begin{align} \mathcal{L}(\theta,\phi;\text{x}^{(i)})&amp; =<br>-\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>\frac{q_{\phi}(\text{z}|\text{x}^{(i)})}{p_{\theta}(\text{z},\text{x}^{(i)})}\<br>&amp;=\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log p_{\theta}(\text{z},<br>\text{x}^{(i)}) - \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>q_{\phi}(\text{z}|\text{x}^{(i)}) \end{align}$</p>
<p>由于KL散度非负，当两个分布一致时（允许在一个零测集上不一致），KL散度为0。于是  $\displaystyle \log<br>p_{\theta}(\text{x}^{(i)}) \geq \mathcal{L}(\theta,\phi;\text{x}^{(i)})$  。<br>$\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)})$  称为对数似然函数的变分下界。</p>
<p>直接优化  $\displaystyle \log p_{\theta}(\text{x}^{(i)})$  是不可行的，因此一般转而优化它的下界<br>$\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)})$  。对应的，优化对数似然函数转化为优化<br>$\displaystyle \mathcal{L}(\theta,\phi;\text{X})=\sum_{i=1}^N<br>\mathcal{L}(\theta,\phi;\text{x}^{(i)})$  。</p>
<p>作者指出，  $\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)})$  对<br>$\displaystyle \phi$  的梯度方差很大，不适于用于数值计算。为了解决这个问题，假定识别模型  $\displaystyle<br>q_{\phi}(\text{z}|\text{x})$  可以写成可微函数  $\displaystyle g_{\phi}(\epsilon,<br>\text{x})$  ，其中，  $\displaystyle \epsilon$  为噪声，  $\displaystyle \epsilon \sim<br>p(\epsilon)$  。于是，  $\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)})$<br>可以做如下估计（利用蒙特卡罗方法估计期望）：</p>
<p>$\displaystyle<br>\mathcal{\tilde{L}}^A(\theta,\phi;\text{x}^{(i)})=\frac{1}{L}\sum_{l=1}^L<br>[\log p_{\theta}(\text{x}^{(i)}, \text{z}^{(i,l)}) - \log<br>q_{\phi}(\text{z}^{(i,l)}|\text{x}^{(i)})]$</p>
<p>其中，  $\displaystyle \text{z}^{(i,l)}=g_{\phi}(\epsilon^{(i,l)},<br>\text{x}^{(i)}), \quad \epsilon^{(i,l)} \sim p(\epsilon)$  。</p>
<p>此外，  $\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)})$  还可以改写为</p>
<p>$\displaystyle<br>\mathcal{L}(\theta,\phi;\text{x}^{(i)})=-KL(q_{\phi}(\text{z}|\text{x}^{(i)})||p_{\theta}(\text{z}))</p>
<ul>
<li>\mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log<br>p_{\theta}(\text{x}^{(i)}|\text{z})$</li>
</ul>
<p>由此可以得到另外一个估计</p>
<p>$\displaystyle \mathcal{\tilde{L}}^B(\theta, \phi;<br>\text{x}^{(i)})=-KL(q_{\phi}(\text{z}|\text{x}^{(i)})||p_{\theta}(\text{z}))<br>+\frac{1}{L} \sum_{l=1}^L \log p_{\theta}(\text{x}^{(i)}|\text{z}^{(i,l)})$</p>
<p>其中，  $\displaystyle \text{z}^{(i,l)}=g_{\phi}(\epsilon^{(i,l)},<br>\text{x}^{(i)}), \quad \epsilon^{(i,l)} \sim p(\epsilon)$  。</p>
<p>实际试验时，如果样本量  $\displaystyle N$<br>很大，我们一般采用minibatch的方法进行学习，对数似然函数的下界可以通过minibatch来估计：</p>
<p>$\displaystyle \mathcal{L}(\theta,\phi;\text{X})\simeq \mathcal{\tilde{L}}^M<br>(\theta,\phi;\text{X}^M)=\frac{N}{M}\sum_{i=1}^M<br>\mathcal{\tilde{L}}(\theta,\phi;\text{x}^{(i)})$</p>
<p>可以看到，为了计算  $\displaystyle \mathcal{L}(\theta,\phi;\text{X})$  ，我们用了两层估计。当<br>$\displaystyle M$  较大时，内层估计可以由外层估计来完成，也就是说，取  $\displaystyle L=1$<br>即可。实际计算中，作者取  $\displaystyle M=100,L=1$  。由上述推导得到AEVB算法：</p>
<p><img src="/2020/07/11/VAE/v2-abcbf504cd361b149caca56fea7c90a3_b.jpg" alt></p>
<h2 id="VAEs模型"><a href="#VAEs模型" class="headerlink" title="VAEs模型"></a>VAEs模型</h2><p>上面给的AEVB算法是一个算法框架，只有给定了  $\displaystyle \epsilon,<br>p_{\theta}(\text{x}|\text{z}), q_{\phi}(\text{z}|\text{x}),<br>p_{\theta}(\text{z})$  分布的形式以及  $\displaystyle g_{\phi}(\epsilon, \text{x})$<br>，我们才能启动算法。实际应用中，作者取</p>
<p>$\displaystyle \begin{align} p(\epsilon) &amp;= \mathcal{N}(\epsilon;<br>0,\text{I})\\ q_{\phi}(\text{z}|\text{x}^{(i)}) &amp;= \mathcal{N}(\text{z};<br>{\mu}^{(i)}, {\sigma}^{2(i)}\text{I})\<br>p_{\theta}(\text{z})&amp;=\mathcal{N}(\text{z}; 0,\text{I})\<br>g_{\phi}(\epsilon^{(l)}, \text{x}^{(i)}) &amp;= {\mu}^{(i)}+{\sigma}^{(i)}\odot<br>\epsilon^{(l)} \end{align}$</p>
<p>而  $\displaystyle p_{\theta}(\text{x}|\text{z})$<br>根据样本是实值还是二元数据进行选择，若样本为二元数据，则选择</p>
<p>$\displaystyle p_{\theta}(x_i|\text{z})=\mathcal{B}(x_i;1,y_i)=y_i^{x_i}\cdot<br>(1-y_i)^{1-x_i}, \quad i=1,2,\cdots,D_{\text x}(D_{\text x}=\dim(\text{x}))$</p>
<p>若样本是实值数据，则选择</p>
<p>$\displaystyle p_{\theta}(\text{x}^{(i)}|\text{z})=\mathcal{N}(\text{x}^{(i)};<br>\mu’^{(i)},\sigma’^{2(i)}\text{I})$</p>
<p>实验中，作者选择多层感知器（MLP）对  $\displaystyle p_{\theta}(\text{x}|\text{z}),<br>q_{\phi}(\text{z}|\text{x})$  进行拟合，具体来说，</p>
<p>对  $\displaystyle p_{\theta}(\text{x}|\text{z})$  ，参数为  $\displaystyle<br>\theta=(\mu’, \sigma’)$  ，若样本为二元数据，则</p>
<p>$\displaystyle \begin{align} \log p(\text{x}|\text{z}) &amp;= \sum_{i=1}^{D_\text<br>x} x_i \log y_i + (1-x_i)\cdot \log (1-y_i)\\ \text{y}&amp;=\text{sigmoid}(\text<br>W_2 \tanh(\text W_1\text{z} + \text b_1) + \text b_2) \end{align}$</p>
<p>若样本为实值数据，则</p>
<p>$\displaystyle \begin{align} \mu’ &amp;= \text{W}_4\text{h}’+\text{b}_4 \<br>\sigma’ &amp;= \text W_5\text{h}’ + \text{b}_5\\ \text{h}’ &amp;= \tanh(\text W_3<br>\text{z} + \text b_3) \end{align}$</p>
<p>对  $\displaystyle q_{\phi}(\text{z}|\text{x})$  ，参数为  $\displaystyle<br>\phi=(\mu, \sigma)$  ，</p>
<p>$\displaystyle \begin{align} \mu &amp;= \text{W}_7\text{h}+\text{b}_7 \\ \sigma<br>&amp;= \text W_8\text{h} + \text{b}_8\\ \text{h} &amp;= \tanh(\text W_6 \text{x} +<br>\text b_6) \end{align}$</p>
<p>根据以上假设的分布，不难计算</p>
<p>$\displaystyle \mathcal{L}(\theta,\phi;\text{x}^{(i)}) \simeq<br>\frac{1}{2}\sum_{j=1}^{D_\text z}(1 + \log ((\sigma_j^{(i)})^2) -<br>(\mu_j^{(i)})^2 - (\sigma_j^{(i)})^2) + \frac{1}{L}\sum_{l=1}^L \log<br>p_{\theta}(\text{x}^{(i)} | \text{z}^{(i,l)})$</p>
<p>其中，  $\displaystyle \text{z}^{(i,l)}=\mu^{(i)}+\sigma^{(i)}<br>\odot\epsilon^{(l)}, \quad \epsilon^{(l)} \sim p(\epsilon)$  。</p>
<p>###loss的推导：<br>$D_{K L}\left(q_{\phi}(z \mid x)|| p_{\theta}(z)\right), p_{\theta}(z) \sim \mathrm{N}(0,1),$ 下面推导过程将 $\left(q_{\phi}(z \mid x) \text { 简化为 } q\right.$<br>$D_{K L}\left(q_{\phi}(z \mid x)|| p_{\theta}(z)\right)=\int q(z) \log \frac{q(z)}{p(z)} d z$<br>$=\int q(z)((\log q(z)-\log p(z)) d z$<br>$=\int q(z)\left(\log \left(\frac{1}{\sqrt{2 \pi \sigma^{2}}} e^{\frac{(z-\mu)^{2}}{2 \sigma^{2}}}\right)-\log \left(\frac{1}{\sqrt{2 \pi}} e^{\frac{(z)^{2}}{2}}\right)\right.$<br>$=\int q(z)\left(\log \frac{1}{\sigma}\right) d z+\int \frac{z^{2}}{2} q(z) d z-\int \frac{(z-\mu)^{2}}{2 \sigma^{2}} q(z)$<br>观察第一项就是常数和概率密度积分求和 观察最后一项，其实就是求方差，因此可以很快得到答案 $\frac{1}{2}$<br>$=\left(\log \frac{1}{\sigma}\right)+\int \frac{1}{2}(z-\mu+\mu)^{2} q(z) d z-\frac{1}{2}$<br>$=\left(\log \frac{1}{\sigma}\right)+\frac{1}{2}\left(\int(z-\mu)^{2} q(z) d z+\int \mu^{2} q(z) d z+2 \int(z-\mu)(\mu) d z\right)-\frac{1}{2}$<br>观察最后一项积分项，是求期望的公式，因此结果为0<br>综上可以得到结果 $D_{K L}\left(q_{\phi}(z \mid x)|| p_{\theta}(z)\right)=\left(\log \frac{1}{\sigma}\right)+\frac{\sigma^{2}+\mu^{2}}{2}-\frac{1}{2}$<br>另一项 $E_{z}\left[\log \left(p_{\theta}(x \mid z)\right)\right],$ 是关于x的后验概率的对数似然，在VAE 中并不对decoder做太强的假设，一般通过一个神经网络来得到正态分 布的均值和方差，因此这一项不能通过解析求出，所以采用采样的方式： $E_{z}\left[\log \left(p_{\theta}(x \mid z)\right)\right]=\frac{1}{L} \sum_{j=1}^{L} \log p_{\theta}\left(x^{i} \mid z^{j}\right)$</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++</p>
<p>最后，我们从auto-encoder的角度来理解VAE，下图给出了VAE训练的时候的网络结构（以实值样本为例， <strong>注意下面两个图中的<br>$\displaystyle \epsilon$  节点并不是bias！而是噪声变量，它的维数与 ** $\displaystyle \text z$<br>**相同。</strong> ）：</p>
<p><img src="/2020/07/11/VAE/v2-852e3ffd0c482de49d69f87b2a4b4d4d_b.jpg" alt></p>
<p>训练好了以后，生成样本采用下面的网络结构：</p>
<p><img src="/2020/07/11/VAE/v2-29f2dfa2d85718320353a3a5f6b426e3_b.jpg" alt></p>
<h2 id="VAE实验效果"><a href="#VAE实验效果" class="headerlink" title="VAE实验效果"></a>VAE实验效果</h2><p>作者在Frey<br>face数据集和MNIST数据集上进行实验，实验得到的数据流形分布如下图所示，可以看出，VAE能够捕捉到图像的结构变化（倾斜角度、圈的位置、形状变化、表情变化等）。这也是VAE的一个好处，它有显式的分布，能够容易地可视化图像的分布。GANs虽然不具有显式的图像分布，但是可以通过对隐变量的插值变化来可视化图像的分布（参见<br><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIzOTY2NTQ5Mg%3D%3D%26mid%3D2247483910%26idx%3D1%26sn%3Da5b88757993bfbe5564986cd6eb17b46%26chksm%3De927ea3dde50632ba9e3abbdfe53b0bc5425dc9e17324aac5c0e2dec1579555193533d737e2c%23rd"> DCGAN
</a><br>）。</p>
<p><img src="/2020/07/11/VAE/v2-a108d9425682f6908e61ccf983d9ac6c_b.jpg" alt></p>
<p>VAE在不同维数的隐变量空间（  $\displaystyle \text z$  ）下生成手写数字的效果如下：</p>
<p><img src="/2020/07/11/VAE/v2-89c819c3fa01903272c0df355bd4473f_b.jpg" alt></p>
<p>可以看出，采用MLP也能产生效果还不错的数字，有趣的是，隐变量维数较低时，生成的图像笔画清晰，但是带有较大的噪声（模糊）；隐变量维数高时，生成的数字部分笔画不清晰，但噪声小。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>VAEs网上的代码很多，下面给了三个基于原始论文[1]的代码，作者修改了激活函数和优化方法以取得更好的收敛性。第四个代码是caffe版本，基于文献[2]。</p>
<p>Tensorflow版本： <a href="https://link.zhihu.com/?target=https%3A//github.com/y0ast/VAE-TensorFlow"> y0ast/VAE-TensorFlow: Implementation of a Variational Auto-<br>Encoder in TensorFlow
</a></p>
<p>Torch版本： <a href="https://link.zhihu.com/?target=https%3A//github.com/y0ast/VAE-Torch"> y0ast/VAE-Torch: Implementation of Variational Auto-Encoder in<br>Torch7 </a></p>
<p>Theano版本： [ y0ast/Variational-Autoencoder: Implementation of a variational<br>Auto-encoder<br>](<a href="https://link.zhihu.com/?target=https%3A//github.com/y0ast/Variational-">https://link.zhihu.com/?target=https%3A//github.com/y0ast/Variational-</a><br>Autoencoder)</p>
<p>Caffe版本： <a href="https://link.zhihu.com/?target=https%3A//github.com/cdoersch/vae_tutorial"> Tutorial on Variational Autoencoders
</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]. Kingma D P, Welling M. Auto-Encoding Variational Bayes[J]. stat, 2014,<br>1050: 10.</p>
<p>[2]. DOERSCH C. Tutorial on Variational Autoencoders[J]. stat, 2016, 1050: 13.</p>
<p>[3]. Blei, David M., “Variational Inference.” Lecture from Princeton,<br>[ <a href="https://www" target="_blank" rel="noopener">https://www</a>.  cs.princeton.edu/course<br>s/archive/fall11/cos597C/lectures/variational-inference-i.pdf<br>](<a href="https://link.zhihu.com/?target=https%3A//www.cs.princeton.edu/courses/archive/fall11/cos597C/lectures/variational-">https://link.zhihu.com/?target=https%3A//www.cs.princeton.edu/courses/archive/fall11/cos597C/lectures/variational-</a><br>inference-i.pdf) .</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/07/11/Pytorch%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%81%E4%B9%9D%E7%A7%8D%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/">
                Pytorch学习之十九种损失函数
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-11</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Pytorch学习之十九种损失函数"><a href="#Pytorch学习之十九种损失函数" class="headerlink" title="Pytorch学习之十九种损失函数"></a>Pytorch学习之十九种损失函数</h1><p>损失函数通过torch.nn包实现，</p>
<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1 基本用法"></a>1 基本用法</h2><p>criterion = LossCriterion() #构造函数有自己的参数<br>loss = criterion(x, y) #调用标准时也有参数2</p>
<h2 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2 损失函数"></a>2 损失函数</h2><h3 id="2-1-L1范数损失-L1Loss"><a href="#2-1-L1范数损失-L1Loss" class="headerlink" title="2-1 L1范数损失 L1Loss"></a>2-1 L1范数损失 L1Loss</h3><p>计算 output 和 target 之差的绝对值。</p>
<p>torch.nn.L1Loss(reduction=’mean’)参数：</p>
<p>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-2-均方误差损失-MSELoss"><a href="#2-2-均方误差损失-MSELoss" class="headerlink" title="2-2 均方误差损失 MSELoss"></a>2-2 均方误差损失 MSELoss</h3><p>计算 output 和 target 之差的均方差。</p>
<p>torch.nn.MSELoss(reduction=’mean’)参数：</p>
<p>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-3-交叉熵损失-CrossEntropyLoss"><a href="#2-3-交叉熵损失-CrossEntropyLoss" class="headerlink" title="2-3 交叉熵损失 CrossEntropyLoss"></a>2-3 交叉熵损失 CrossEntropyLoss</h3><p>当训练有 C 个类别的分类问题时很有效. 可选参数 weight 必须是一个1维 Tensor, 权重将被分配给各个类别. 对于不平衡的训练集非常有效。<br>在多分类任务中，经常采用 softmax 激活函数+交叉熵损失函数，因为交叉熵描述了两个概率分布的差异，然而神经网络输出的是向量，并不是概率分布的形式。所以需要 softmax激活函数将一个向量进行“归一化”成概率分布的形式，再采用交叉熵损失函数计算 loss。</p>
<p>torch.nn.CrossEntropyLoss(weight=None, ignore_index=-100, reduction=’mean’)参数：</p>
<p>weight (Tensor, optional) – 自定义的每个类别的权重. 必须是一个长度为 C 的 Tensor<br>ignore_index (int, optional) – 设置一个目标值, 该目标值会被忽略, 从而不会影响到 输入的梯度。<br>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-4-KL-散度损失-KLDivLoss"><a href="#2-4-KL-散度损失-KLDivLoss" class="headerlink" title="2-4 KL 散度损失 KLDivLoss"></a>2-4 KL 散度损失 KLDivLoss</h3><p>计算 input 和 target 之间的 KL 散度。KL 散度可用于衡量不同的连续分布之间的距离, 在连续的输出分布的空间上(离散采样)上进行直接回归时 很有效.</p>
<p>torch.nn.KLDivLoss(reduction=’mean’)参数：</p>
<p>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-5-二进制交叉熵损失-BCELoss"><a href="#2-5-二进制交叉熵损失-BCELoss" class="headerlink" title="2-5 二进制交叉熵损失 BCELoss"></a>2-5 二进制交叉熵损失 BCELoss</h3><p>二分类任务时的交叉熵计算函数。用于测量重构的误差, 例如自动编码机. 注意目标的值 t[i] 的范围为0到1之间.</p>
<p>torch.nn.BCELoss(weight=None, reduction=’mean’)参数：</p>
<p>weight (Tensor, optional) – 自定义的每个 batch 元素的 loss 的权重. 必须是一个长度为 “nbatch” 的 的 Tensor<br>pos_weight(Tensor, optional) – 自定义的每个正样本的 loss 的权重. 必须是一个长度 为 “classes” 的 Tensor</p>
<h3 id="2-6-BCEWithLogitsLoss"><a href="#2-6-BCEWithLogitsLoss" class="headerlink" title="2-6 BCEWithLogitsLoss"></a>2-6 BCEWithLogitsLoss</h3><p>BCEWithLogitsLoss损失函数把 Sigmoid 层集成到了 BCELoss 类中. 该版比用一个简单的 Sigmoid 层和 BCELoss 在数值上更稳定, 因为把这两个操作合并为一个层之后, 可以利用 log-sum-exp 的 技巧来实现数值稳定.</p>
<p>torch.nn.BCEWithLogitsLoss(weight=None, reduction=’mean’, pos_weight=None)参数：</p>
<p>weight (Tensor, optional) – 自定义的每个 batch 元素的 loss 的权重. 必须是一个长度 为 “nbatch” 的 Tensor<br>pos_weight(Tensor, optional) – 自定义的每个正样本的 loss 的权重. 必须是一个长度 为 “classes” 的 Tensor</p>
<h3 id="2-7-MarginRankingLoss"><a href="#2-7-MarginRankingLoss" class="headerlink" title="2-7 MarginRankingLoss"></a>2-7 MarginRankingLoss</h3><p>torch.nn.MarginRankingLoss(margin=0.0, reduction=’mean’)对于 mini-batch(小批量) 中每个实例的损失函数如下:</p>
<p>参数：</p>
<p>margin:默认值0</p>
<h3 id="2-8-HingeEmbeddingLoss"><a href="#2-8-HingeEmbeddingLoss" class="headerlink" title="2-8 HingeEmbeddingLoss"></a>2-8 HingeEmbeddingLoss</h3><p>torch.nn.HingeEmbeddingLoss(margin=1.0,  reduction=’mean’)对于 mini-batch(小批量) 中每个实例的损失函数如下:</p>
<p>参数：</p>
<p>margin:默认值1</p>
<h3 id="2-9-多标签分类损失-MultiLabelMarginLoss"><a href="#2-9-多标签分类损失-MultiLabelMarginLoss" class="headerlink" title="2-9 多标签分类损失 MultiLabelMarginLoss"></a>2-9 多标签分类损失 MultiLabelMarginLoss</h3><p>torch.nn.MultiLabelMarginLoss(reduction=’mean’)对于mini-batch(小批量) 中的每个样本按如下公式计算损失:</p>
<h3 id="2-10-平滑版L1损失-SmoothL1Loss"><a href="#2-10-平滑版L1损失-SmoothL1Loss" class="headerlink" title="2-10 平滑版L1损失 SmoothL1Loss"></a>2-10 平滑版L1损失 SmoothL1Loss</h3><p>也被称为 Huber 损失函数。</p>
<p>torch.nn.SmoothL1Loss(reduction=’mean’)<br>其中</p>
<h3 id="2-11-2分类的logistic损失-SoftMarginLoss"><a href="#2-11-2分类的logistic损失-SoftMarginLoss" class="headerlink" title="2-11 2分类的logistic损失 SoftMarginLoss"></a>2-11 2分类的logistic损失 SoftMarginLoss</h3><p>torch.nn.SoftMarginLoss(reduction=’mean’)</p>
<h3 id="2-12-多标签-one-versus-all-损失-MultiLabelSoftMarginLoss"><a href="#2-12-多标签-one-versus-all-损失-MultiLabelSoftMarginLoss" class="headerlink" title="2-12 多标签 one-versus-all 损失 MultiLabelSoftMarginLoss"></a>2-12 多标签 one-versus-all 损失 MultiLabelSoftMarginLoss</h3><p>torch.nn.MultiLabelSoftMarginLoss(weight=None, reduction=’mean’)</p>
<h3 id="2-13-cosine-损失-CosineEmbeddingLoss"><a href="#2-13-cosine-损失-CosineEmbeddingLoss" class="headerlink" title="2-13 cosine 损失 CosineEmbeddingLoss"></a>2-13 cosine 损失 CosineEmbeddingLoss</h3><p>torch.nn.CosineEmbeddingLoss(margin=0.0, reduction=’mean’)<br>参数：</p>
<p>margin:默认值0</p>
<h3 id="2-14-多类别分类的hinge损失-MultiMarginLoss"><a href="#2-14-多类别分类的hinge损失-MultiMarginLoss" class="headerlink" title="2-14 多类别分类的hinge损失 MultiMarginLoss"></a>2-14 多类别分类的hinge损失 MultiMarginLoss</h3><p>torch.nn.MultiMarginLoss(p=1, margin=1.0, weight=None,  reduction=’mean’)<br>参数：</p>
<p>p=1或者2 默认值：1<br>margin:默认值1</p>
<h3 id="2-15-三元组损失-TripletMarginLoss"><a href="#2-15-三元组损失-TripletMarginLoss" class="headerlink" title="2-15 三元组损失 TripletMarginLoss"></a>2-15 三元组损失 TripletMarginLoss</h3><p>torch.nn.TripletMarginLoss(margin=1.0, p=2.0, eps=1e-06, swap=False, reduction=’mean’)<br>其中：</p>
<h3 id="2-16-连接时序分类损失-CTCLoss"><a href="#2-16-连接时序分类损失-CTCLoss" class="headerlink" title="2-16 连接时序分类损失 CTCLoss"></a>2-16 连接时序分类损失 CTCLoss</h3><p>CTC连接时序分类损失，可以对没有对齐的数据进行自动对齐，主要用在没有事先对齐的序列化数据训练上。比如语音识别、ocr识别等等。</p>
<p>torch.nn.CTCLoss(blank=0, reduction=’mean’)参数：</p>
<p>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-17-负对数似然损失-NLLLoss"><a href="#2-17-负对数似然损失-NLLLoss" class="headerlink" title="2-17 负对数似然损失 NLLLoss"></a>2-17 负对数似然损失 NLLLoss</h3><p>负对数似然损失. 用于训练 C 个类别的分类问题.</p>
<p>torch.nn.NLLLoss(weight=None, ignore_index=-100,  reduction=’mean’)参数：</p>
<p>weight (Tensor, optional) – 自定义的每个类别的权重. 必须是一个长度为 C 的 Tensor<br>ignore_index (int, optional) – 设置一个目标值, 该目标值会被忽略, 从而不会影响到 输入的梯度.</p>
<h3 id="2-18-NLLLoss2d"><a href="#2-18-NLLLoss2d" class="headerlink" title="2-18 NLLLoss2d"></a>2-18 NLLLoss2d</h3><p>对于图片输入的负对数似然损失. 它计算每个像素的负对数似然损失.</p>
<p>torch.nn.NLLLoss2d(weight=None, ignore_index=-100, reduction=’mean’)参数：</p>
<p>weight (Tensor, optional) – 自定义的每个类别的权重. 必须是一个长度为 C 的 Tensor<br>reduction-三个值，none: 不使用约简；mean:返回loss和的平均值； sum:返回loss的和。默认：mean。</p>
<h3 id="2-19-PoissonNLLLoss"><a href="#2-19-PoissonNLLLoss" class="headerlink" title="2-19 PoissonNLLLoss"></a>2-19 PoissonNLLLoss</h3><p>目标值为泊松分布的负对数似然损失</p>
<p>torch.nn.PoissonNLLLoss(log_input=True, full=False,  eps=1e-08,  reduction=’mean’)参数：</p>
<p>log_input (bool, optional) – 如果设置为 True , loss 将会按照公 式 exp(input) - target * input 来计算, 如果设置为 False , loss 将会按照 input - target * log(input+eps) 计算.<br>full (bool, optional) – 是否计算全部的 loss, i. e. 加上 Stirling 近似项 target * log(target) - target + 0.5 * log(2 * pi * target).<br>eps (float, optional) – 默认值: 1e-8</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/07/09/CVAE/">
                CVAE
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-09</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="VAE回顾"><a href="#VAE回顾" class="headerlink" title="VAE回顾"></a>VAE回顾</h2><p>VAE的目标是最大化对数似然函数</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csum_i+%5Clog+p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%5E%7B%28i%29%7D%29%3D%5Csum_i+KL%28q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%7D%5E%7B%28i%29%7D%29%7C%7Cp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%7D%5E%7B%28i%29%7D%29%29+%2B+%5Csum_i+%5Cmathcal%7BL%7D%28%5Ctheta%2C%5Cphi%3B%5Ctext%7Bx%7D%5E%7B%28i%29%7D%29" alt="[公式]"></p>
<p>其中，</p>
<p>$\mathcal{L}(\theta, \phi; \text{x}^{(i)}) = \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x})} [\log p_{\theta}(\text{x,z}) - \log q_{\phi}(\text{z}|\text{x})]= -KL(q_{\phi}(\text{z}|\text{x}^{(i)})||p_{\theta}(\text{z})) + \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x}^{(i)})} \log p_{\theta}(\text{x}^{(i)}|\text{z})$</p>
<p>由于KL散度非负，对数似然函数的变分下界即为上式中的<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D" alt="[公式]">)项。一般来说，<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%7D%5E%7B%28i%29%7D%29" alt="[公式]">)是未知的，或者难以获得显式表达式的，因此，直接优化对数似然函数是不可行的，一般转而优化它的变分下界，即上式中的<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D" alt="[公式]">项。Diederik P.Kingma和Max Welling提出了两个算法SGVB和AEVB去估计<img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D" alt="[公式]">。</p>
<h2 id="CVAE"><a href="#CVAE" class="headerlink" title="CVAE"></a>CVAE</h2><p>VAE用的训练集是数据<img src="https://www.zhihu.com/equation?tex=%5C%7B%5Ctext%7Bx%7D%5E%7B%28i%29%7D%5C%7D_%7Bi%3D1%7D%5EN" alt="[公式]">)。当生成数据时，由隐变量<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bz%7D" alt="[公式]">)控制生成数据<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)，如果我们现在有的数据不只是<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)，我们还有关于数据<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)的一些额外信息<img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D" alt="[公式]">，最简单的，以手写数字为例，它的标签0-9，那么我们是否能够利用上这些额外的信息呢？</p>
<p><strong>CVAE-1</strong></p>
<p>一个简答的想法，考虑条件概率分布<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%7D%29" alt="[公式]">，套用原来的VAE模型，我们不难作出以下推导：</p>
<p>$KL(q_{\phi}(\text{z}|\text{x,y})||p_{\theta}(\text{z}|\text{x,y})) = \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} \log \frac{q_{\phi}(\text{z}|\text{x,y})}{p_{\theta}(\text{z}|\text{x,y})} \<br>= \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} \log \frac{q_{\phi}(\text{z}|\text{x,y}) p_{\theta}(\text{x}|\text{y})}{p_{\theta}(\text{z}|\text{x,y}) p_{\theta}(\text{x}|\text{y})} \<br>= \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} \log \frac{q_{\phi}(\text{z}|\text{x,y}) p_{\theta}(\text{x}|\text{y})}{p_{\theta}(\text{x,z}|\text{y})} \<br>= KL(q_{\phi}(\text{z}|\text{x,y}) || p_{\theta}(\text{x,z}|\text{y})) + \log p_{\theta}(\text{x}|\text{y}))$</p>
<p>于是</p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Clog+p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%7D%29%29+%3D+KL%28q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7C%7Cp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%29+%2B+%5Cmathcal%7BL%7D%28%5Ctheta%2C%5Cphi%3B%5Ctext%7Bx%2Cy%7D%29" alt="[公式]"></p>
<p>其中，</p>
<p>$\mathcal{L}(\theta,\phi;\text{x,y}) = -KL(q_{\phi}(\text{z}|\text{x,y}) || p_{\theta}(\text{x,z}|\text{y})) \<br>= \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} [\log p_{\theta}(\text{x,z}|\text{y}) - \log q_{\phi}(\text{z}|\text{x,y})] \<br>= -KL(q_{\phi}(\text{z}|\text{x,y})||p_{\theta}(\text{z}|\text{y})) + \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} \log p_{\theta}(\text{x}|\text{y,z})$</p>
<p>类似于VAE，套用SGVB算法，再做一下reparameterization，取适当的分布和网络，我们就得到了一个CVAE模型。</p>
<p>我们姑且称这个版本的CVAE为CVAE-1模型，没错，CVAE模型不止一个……</p>
<p><strong>CVAE-2</strong></p>
<p>此外，与CGAN一样，我们一般假设额外信息<img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D" alt="[公式]">)与隐变量<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bz%7D" alt="[公式]">)没有直接的关系，因此条件概率<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7By%7D%29%3Dp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%29" alt="[公式]">，于是变分下界可以写成</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D%28%5Ctheta%2C%5Cphi%3B%5Ctext%7Bx%2Cy%7D%29+%3D+-KL%28q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7C%7Cp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%29%29+%2B+%5Cmathbb%7BE%7D_%7Bq_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7D+%5Clog+p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%2Cz%7D%29" alt="[公式]"></p>
<p>这在文献[3]中提到过。姑且称这个版本为CVAE-2模型。</p>
<p><strong>CVAE-3</strong></p>
<p>这就完了吗？文献[2]会告诉你，不要着急，我们也提出了一种CVAE。文中提出的方法不是产生数据<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)，而是直接考虑预测问题：预测数据<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)的标签<img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D" alt="[公式]">)。什么意思呢？它的似然函数是<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7By%7D%7C%5Ctext%7Bx%7D%29" alt="[公式]">)而不是<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%7D%29" alt="[公式]">)。而这个推导也不难，事实上，把<img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D" alt="[公式]">)看成我们要生成的“数据”，<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">)看成是“标签”，在上面推导的结果里面直接交换<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D%2C+%5Ctext%7By%7D" alt="[公式]">的位置，就得到了</p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Clog+p_%7B%5Ctheta%7D%28%5Ctext%7By%7D%7C%5Ctext%7Bx%7D%29%29+%3D+KL%28q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7C%7Cp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%29+%2B+%5Cmathcal%7BL%7D%28%5Ctheta%2C%5Cphi%3B%5Ctext%7Bx%2Cy%7D%29" alt="[公式]"></p>
<p>其中，</p>
<p>$\mathcal{L}(\theta,\phi;\text{x,y}) = -KL(q_{\phi}(\text{z}|\text{x,y}) || p_{\theta}(\text{y,z}|\text{x})) \<br>= \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} [\log p_{\theta}(\text{y,z}|\text{x}) - \log q_{\phi}(\text{z}|\text{x,y})] \<br>= -KL(q_{\phi}(\text{z}|\text{x,y})||p_{\theta}(\text{z}|\text{x})) + \mathbb{E}<em>{q</em>{\phi}(\text{z}|\text{x,y})} \log p_{\theta}(\text{y}|\text{x,z})$</p>
<p>同样地，对<img src="https://www.zhihu.com/equation?tex=q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29" alt="[公式]">)做一下reparameterization，写成<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bz%7D+%3D+g_%7B%5Cphi%7D%28%5Ctext%7Bx%2Cy%7D%2C%5Cepsilon%29%2C+%5Cepsilon+%5Csim+%5Cmathcal%7BN%7D%280%2CI%29" alt="[公式]">)。再取适当的分布和网络，就可以了。值得一提的是，我们会在模型中设定适当的分布<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7By%7D%7C%5Ctext%7Bx%2Cz%7D%29" alt="[公式]">)，当训练完了以后，可以把模型当成一个分类器，预测输入<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bx%7D" alt="[公式]">的标签：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D%5E%2A%3D%5Carg%5Cmax_%7B%5Ctext%7By%7D%7Dp_%7B%5Ctheta%7D%28%5Ctext%7By%7D%7C%5Ctext%7Bx%7D%2C%5Ctext%7Bz%7D%5E%2A%29%2C+%5Cquad+%5Ctext%7Bz%7D%5E%2A%3D%5Cmathbb%7BE%7D%5B%5Ctext%7Bz%7D%7C%5Ctext%7Bx%7D%5D" alt="[公式]"></p>
<p>上面的预测涉及到求期望，除非有显式结果，否则一般采用均值去近似期望：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D%5E%2A%3D%5Carg%5Cmax_%7B%5Ctext%7By%7D%7D+%5Cfrac%7B1%7D%7BL%7D+%5Csum_%7Bl%3D1%7D%5EL+p_%7B%5Ctheta%7D%28%5Ctext%7By%7D%7C%5Ctext%7Bx%7D%2C%5Ctext%7Bz%7D%5E%7B%28l%29%7D%29%2C+%5Cquad+%5Ctext%7Bz%7D%5E%7B%28l%29%7D+%5Csim+p_%5Ctheta%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%7D%29" alt="[公式]"></p>
<p>姑且这个模型称为CVAE-3，它的图模型结构如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8a0cc590d0edc95dcd10e8adbf8772e8_1440w.jpg" alt="img"></p>
<p><strong>CVAE-4</strong></p>
<p>非常抱歉地告诉你，CVAE模型还没完。文献[3]提出了CMMA模型（conditional multimodal autoencoder），实际上它也可以看成是条件版本的VAE。一般来说，我们考虑的CVAE或者CGAN的图模型是长这样的：</p>
<p><img src="https://pic3.zhimg.com/80/v2-efeb6d666dbfcd69c467a643df811c66_1440w.jpg" alt="img"></p>
<p>它的特点是<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bz%7D%2C+%5Ctext%7By%7D" alt="[公式]">一般是相互独立的。而CMMA考虑的图模型是长这样的：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aa979cafea50272ca0017dd8d866180c_1440w.jpg" alt="img"></p>
<p>这个模型的特点是隐变量是由额外信息<img src="https://www.zhihu.com/equation?tex=%5Ctext%7By%7D" alt="[公式]">)确定的，<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%2Cz%7D%29%3Dp_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7Bz%7D%29" alt="[公式]">)。整个推导过程跟CVAE-1一模一样，应用<img src="https://www.zhihu.com/equation?tex=p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7By%2Cz%7D%29%3Dp_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7Bz%7D%29" alt="[公式]">以后，变分下界可以简化为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D%28%5Ctheta%2C%5Cphi%3B%5Ctext%7Bx%2Cy%7D%29+%3D+-KL%28q_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7C%7Cp_%7B%5Ctheta%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7By%7D%29%29+%2B+%5Cmathbb%7BE%7D_%7Bq_%7B%5Cphi%7D%28%5Ctext%7Bz%7D%7C%5Ctext%7Bx%2Cy%7D%29%7D+%5Clog+p_%7B%5Ctheta%7D%28%5Ctext%7Bx%7D%7C%5Ctext%7Bz%7D%29" alt="[公式]"></p>
<p>姑且称CMMA模型为CVAE-4。CVAE-4模型将标签信息编码到隐变量<img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bz%7D" alt="[公式]">中，作者指出，这样做的效果更好。</p>
<p>当然，针对具体的问题，还有一些不一样的CVAE设计，例如，文献[1]用CVAE做半监督学习，用到的CVAE又与上面介绍的有所不同。根据具体问题，有些模型还会对目标函数添加一些惩罚项。</p>
<p>VAE是个贝叶斯模型，它的条件概率版本根据取条件概率的形式的不同，自然会出现多种多样的模型。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>\1. <a href="https://link.zhihu.com/?target=https%3A//github.com/RuiShu/cvae">RuiShu/cvae: Conditional variational autoencoder implementation in Torch</a></p>
<p>\2. <a href="https://link.zhihu.com/?target=https%3A//github.com/kastnerkyle/SciPy2015">kastnerkyle/SciPy2015: Talk for SciPy2015 “Deep Learning: Tips From The Road”</a></p>
<p>\3. <a href="https://link.zhihu.com/?target=https%3A//github.com/cdoersch/vae_tutorial">Tutorial on Variational Autoencoders</a></p>
<p>\4. <a href="https://link.zhihu.com/?target=https%3A//github.com/dpkingma/nips14-ssl">dpkingma/nips14-ssl: Code for reproducing results of NIPS 2014 paper “Semi-Supervised Learning with Deep Generative Models”</a></p>
<p>\5. <a href="https://link.zhihu.com/?target=https%3A//github.com/jramapuram/CVAE">jramapuram/CVAE: Convolutional Variational Autoencoder</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>\1. Kingma D P, Mohamed S, Rezende D J, et al. Semi-supervised learning with deep generative models[C]//Advances in Neural Information Processing Systems. 2014: 3581-3589.</p>
<p>\2. Sohn K, Lee H, Yan X. Learning structured output representation using deep conditional generative models[C]//Advances in Neural Information Processing Systems. 2015: 3483-3491.</p>
<p>\3. Pandey G, Dukkipati A. Variational methods for conditional multimodal learning: Generating human faces from attributes. arXiv preprint[J]. arXiv, 2016, 1603.</p>
<p>\4. Walker J, Doersch C, Gupta A, et al. An uncertain future: Forecasting from static images using variational autoencoders[C]//European Conference on Computer Vision. Springer International Publishing, 2016: 835-851.</p>
<p>\5. Doersch C. Tutorial on variational autoencoders[J]. arXiv preprint arXiv:1606.05908, 2016.</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/06/05/%E8%BF%9C%E7%A8%8B%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%9C%89%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%8F%E8%AE%A1%E5%B0%B1%E5%A4%9F%E4%BA%86/">
                远程深度学习，有这一篇小计就够了
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="远程深度学习，有这一篇小计就够了"><a href="#远程深度学习，有这一篇小计就够了" class="headerlink" title="远程深度学习，有这一篇小计就够了"></a>远程深度学习，有这一篇小计就够了</h1><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>作者：北静王<br>链接：<a href="https://www.jianshu.com/p/cfcc2b197308" target="_blank" rel="noopener">https://www.jianshu.com/p/cfcc2b197308</a><br>来源：简书</p>
<blockquote>
<p>没有GPU搞什么深度学习，用嘴么。</p>
</blockquote>
<blockquote>
<p>在服务器上运行代码的时候一定一定一定要给别的用户留出一定的使用空间</p>
</blockquote>
<p>终于从纸上谈兵到实际编码操作，切忌自己独占系统资源。本篇小记重点讲：</p>
<ol>
<li>怎么远程调试代码</li>
<li>怎么远程运行代码</li>
<li>深度学习的设置</li>
</ol>
<h3 id="零、关于远程服务器的一些小诀窍"><a href="#零、关于远程服务器的一些小诀窍" class="headerlink" title="零、关于远程服务器的一些小诀窍"></a>零、关于远程服务器的一些小诀窍</h3><h4 id="1-关于怎么选择GPU和限制显存问题。"><a href="#1-关于怎么选择GPU和限制显存问题。" class="headerlink" title="1. 关于怎么选择GPU和限制显存问题。"></a>1. 关于怎么选择GPU和限制显存问题。</h4><p>Tensorflow默认是占尽全部显存的，即使你的代码网络结构不占用很大的现存的时候，tf也会默认全部申请是为了在程序运行的过程中直接取用不用再申请操作显存，所有有的时候回看到明明是一个很小的代码却占尽了GPU显存，但是GPU得计算力却还不到30%，尤其是在多个CPU的时候，每块GPU的显存都申请满了，而只有一颗GPU在跑程序。所以我们有必要手动的修改下自己的代码，只需要在关键的地方添上几句代码，就会限制显存使用，同时还能指定跑程序的GPU。如果参数选择的正确的话对程序的运行速度是没有限制的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES&#x3D;0 python nn.py</span><br></pre></td></tr></table></figure>

<p>将Tensoeflow的命令行参数写在python之前，指明你要使用的GPU，<code>0</code>代表第一块GPU，<code>0，1</code>代表使用设备号是0和1的两块GPU。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用tf.flags 传递参数</span><br><span class="line">在session中使用限制显存的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tf.app.flags.DEFINE_float(<span class="string">'mr'</span>,0.5,<span class="string">'allocate GPU memory rate'</span>)</span><br><span class="line">FLAGS=tf.app.flags.FLAGS</span><br><span class="line">gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=FLAGS.mr)</span><br><span class="line">session = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</span><br></pre></td></tr></table></figure>

<p>上面的GPUOptions就限制了你的显存的使用率。并且我们使用tf.flags可以直接运行python程序的时候通过命令行参数来指定这个分配现存的大小。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用第一块GPU，并且只使用第一块GPU20%的显存做计算。</span></span><br><span class="line">CUDA_VISIBLE_DEVICES=0 python nn.py --mr=0.2</span><br></pre></td></tr></table></figure>

<h4 id="2-后台运行"><a href="#2-后台运行" class="headerlink" title="2. 后台运行"></a>2. 后台运行</h4><p>只需要在运行命令行之后添加一个<code>&amp;</code>符号便可以将当前的进程挂到后台。但是一定要记得如果不再使用当前进程的话，用<code>Ctrl+c</code>是杀不掉的，一定要使用<code>kill</code>命令杀线程。</p>
<p>在挂后台的时候，会返给命令行一个PID，就是进程的ID号，最好记下来这个ID号，因为你手动杀进程的时候需要使用这个ID号，一定不能记错了，否则杀了别人的进程是小事，把系统搞奔溃了可就麻烦了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -s 9 代表着强制杀掉进程，百杀百中</span></span><br><span class="line">sudo <span class="built_in">kill</span> -s 9 PID</span><br></pre></td></tr></table></figure>

<p>有时候忘记了进程号，我们需要查找当前活跃的进程，然后找到这个进程号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep <span class="string">"python"</span></span><br></pre></td></tr></table></figure>

<p>这里是两个shell命令通过管道进行了结合，第一个ps能够列出当前系统所有活跃的进程，然后通过grep 关键字查找就能找到带有关键字的进程。找到PID（PID是输出的第二列那个数字）再杀掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前使用的登录终端ID，</span></span><br><span class="line">他的输出也可以当做前面的grep的关键字来进行线程的查询，</span><br><span class="line">但是要记住使用同一个窗口。</span><br><span class="line">tty</span><br></pre></td></tr></table></figure>

<p>最好的方法是通过你运行的终端的命令来进行关键词查找，这样最准确。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-a553aa5f89b6c8da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>挺简单的</p>
<h4 id="3-使用ssh-keygen-完成免密码登录"><a href="#3-使用ssh-keygen-完成免密码登录" class="headerlink" title="3. 使用ssh-keygen 完成免密码登录"></a>3. 使用ssh-keygen 完成免密码登录</h4><p><img src="https:////upload-images.jianshu.io/upload_images/1726419-800e7f0ad9520674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/706/format/webp" alt="img"></p>
<p>只使用f3一个命令就完成了免密码登录</p>
<h4 id="4-监视服务器运行状态的小命令"><a href="#4-监视服务器运行状态的小命令" class="headerlink" title="4. 监视服务器运行状态的小命令"></a>4. 监视服务器运行状态的小命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop  <span class="comment">#监视内存，线程，CPU运行状态</span></span><br></pre></td></tr></table></figure>

<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-df651fcf834eaf24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/962/format/webp" alt="img"></p>
<p>Screen Shot 2018-01-10 at 23.16.59.png</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">watch</span> <span class="selector-tag">-n</span> 0<span class="selector-class">.2</span> <span class="selector-tag">nvidia-smi</span> #监视<span class="selector-tag">GPU</span>，每隔0<span class="selector-class">.2s</span> 刷新</span><br></pre></td></tr></table></figure>

<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-666758a403398769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/956/format/webp" alt="img"></p>
<p>Screen Shot 2018-01-10 at 23.17.05.png</p>
<h3 id="一、-远程调试代码"><a href="#一、-远程调试代码" class="headerlink" title="一、 远程调试代码"></a>一、 远程调试代码</h3><p>必备条件：</p>
<ul>
<li>Pycharm pro（一定要是pro版本，负责不支持以下操作）</li>
<li>Shell （有兴趣的同学可以去设置zsh和iterm2）</li>
<li>conda （主要是为了服务器用户隔离）</li>
</ul>
<p>步骤：<br> Pycharm pro中有许多很牛逼很帅的高级功能，现在我们需要用到的是【development】功能来实现远程的python脚本的修改调试。此功能在【tools】-&gt;【development】中。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-42a83144f3675a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/690/format/webp" alt="img"></p>
<p>选中Configuration功能进行配置</p>
<p>下面就是使用类ssh的功能来远程连接主机了，请确定你已经在远程服务器上面添加了自己的账户。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-710d4497248f7337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1016/format/webp" alt="img"></p>
<p>配置</p>
<p><code>name</code>则是整个配置的名称，随便你命名。<br> <code>Type</code>选择SFTP。<br> <code>host</code>直接填写远程服务器的IP地址（例如：xxx.xxx.xxx.xxx）。<br> <code>Root path</code>则是你远程服务器上面的代码存放位置，我一般就是在我的用户目录下直接建立code，这样比较方便。<br> <code>User name</code>和<code>Password</code>则是你远程服务上的用户名和密码。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-0981d6459dec1ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="img"></p>
<p>本地和远程的mapping的设置</p>
<p><code>localPath</code>就是你本地的项目上的代码位置，如果你是用Pycharm pro直接open的项目的话，name这个地方是自动填充自己的项目位置的。<br><code>Development Path on sever &#39;***&#39;</code> 则是你在服务上要上传代码的位置。上传完成之后会在服务器的Root path下新建一个文件夹，就是这个名称。<br><code>Web path</code>这个不用管。</p>
<p>之后需要设置Pycharm，让他在远程服务器上能够建立文件夹，这样即使我们首次上传也不会出现远程服务器没有文件夹的问题。<br> 还是在之前【development】那里，这次我们选择的是下面的【options】选项。将第五个checkbox <code>create empty directories</code>勾选上就可以了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-75dd51bb71ec2cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/898/format/webp" alt="img"></p>
<p>Screen Shot 2018-01-10 at 22.50.13.png</p>
<p>下面就可以上传本地的项目到远程的服务器上面了。不过在此之前请确定你远程的服务器上有你的用户，并且你的用户目录有<code>write</code>权限，关于用户权限你可以用<code>ls -l</code>查看目录下的文件，第一列就列出了用户权限。请自行百度，如果你自己的用户在你用户目录下没有<code>write</code>的权限的话，那么即使连接上了远程服务器也不能成功上传，原因就是你没有建立文件夹和文件的权限。可以使用下面的命令修复。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-tag">-l</span></span><br><span class="line"></span><br><span class="line">显示</span><br><span class="line"><span class="selector-tag">-rwxr-xr-x</span> 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 6444 09<span class="selector-tag">-22</span> 15<span class="selector-pseudo">:33</span> <span class="selector-tag">shmwrite</span></span><br><span class="line"><span class="selector-tag">-rw-r--r--</span> 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 1443 09<span class="selector-tag">-22</span> 15<span class="selector-pseudo">:33</span> <span class="selector-tag">shmwrite</span><span class="selector-class">.c</span></span><br><span class="line"><span class="selector-tag">drwxr-xr-x</span> 2 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 4096 09<span class="selector-tag">-22</span> 17<span class="selector-pseudo">:19</span> <span class="selector-tag">test</span></span><br></pre></td></tr></table></figure>

<p>第一个字符代表文件类型。d代表目录,-代表非目录。</p>
<p>接下来每三个字符为一组权限，分为三组，依次代表所有者权限，同组用户权限，其它用户权限.每组权限的三个字符依次代表是否可读，是否可写，是否可执行</p>
<p>r 表示拥有读的权限<br> w 表示拥有写的权限<br> x 表示拥有可执行的权限<br> - 表示没有该权限</p>
<p>修改权限<br> 可用chmod命令来修改文件权限。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R XXX floderName</span><br><span class="line">sudo chmod XXX fileName</span><br><span class="line">sudo chown user:<span class="keyword">group</span> fileName</span><br></pre></td></tr></table></figure>

<p>前两条命令表示改变文件属性（文件三种属性，read-可读，write-可写，x-可执行）。按照二进制来计算没组权限的属性就OK了，具体的请自行学习查询，这里不展开了。</p>
<p>然后我们在Pycharm pro中的项目上，鼠标右键菜单下部会出现<code>upload to name</code>选项，选择以后就能完成文件的上传了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-ef1731ffd5dde1d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp" alt="img"></p>
<p>当我们修改了某一个文件时候，也可以单独上传一个文件</p>
<h3 id="二、设置远程调试解析器"><a href="#二、设置远程调试解析器" class="headerlink" title="二、设置远程调试解析器"></a>二、设置远程调试解析器</h3><p>远程服务器上一般安装有conda和virtualenv虚拟软件，大家一定一定一定要花点时间来学习conda的虚拟环境，一定一定一定不要和别人公用虚拟环境，一般自己的虚拟环境自己维护，用自己的用户名做前缀防止别人给你修改。这对服务器的维护和软件的运行都是很有益处的。</p>
<p>假设你已经在服务器上建立好了自己的python虚拟环境，那么下一步就是设置Pycharm的解释器了。我们只需要将解释器的位置设置为远程地址就行。</p>
<p>首先查看你远程服务器上的虚拟环境中的python解释器的位置。找到anaconda的安装位置，一般安装的人是为一个用户安装的也就是root用户，此时你需要找到root用户下的conda的位置。然后在env文件下找到你的虚拟环境目录，然后在/bin目录下查找python2.7。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-cafcb896c4358e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1054/format/webp" alt="img"></p>
<p>添加Remote Interpreters</p>
<p>稍后Pycharm会从远程的服务器上pull下服务器的conda环境到本机。完成之后就能debug远程服务器的代码了。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1726419-7e1f70509e597dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>调试窗口</p>
<p>我们可以从调试窗口第一行的启动命令看出，此时候用的是远程的解释器。这样再也不用担心自己的笔记本运行不了了，还得一遍一遍的修改上传再启动。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/06/05/COCO%20%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AD%89%E7%9B%B8%E5%85%B3%E8%AF%84%E6%B5%8B%E6%8C%87%E6%A0%87/">
                COCO 数据集目标检测等相关评测指标
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="COCO-数据集目标检测等相关评测指标"><a href="#COCO-数据集目标检测等相关评测指标" class="headerlink" title="COCO 数据集目标检测等相关评测指标"></a>COCO 数据集目标检测等相关评测指标</h1><p>转载自 <a href="https://www.aiuai.cn/aifarm854.html" target="_blank" rel="noopener">https://www.aiuai.cn/aifarm854.html</a></p>
<blockquote>
<p><a href="http://cocodataset.org/#detection-eval" target="_blank" rel="noopener">COCO Detection Evaluation</a></p>
</blockquote>
<h2 id="1-评测指标定义"><a href="#1-评测指标定义" class="headerlink" title="1. 评测指标定义"></a>1. 评测指标定义</h2><p>COCO 提供了 12 种用于衡量目标检测器性能的评价指标.</p>
<p><a href="https://aiuai.cn/uploads/1905/3c3629c01306058c.png" target="_blank" rel="noopener"><img src="https://aiuai.cn/uploads/1905/3c3629c01306058c.png" alt="image"></a></p>
<p><a href="https://aiuai.cn/uploads/1905/3c3629c01306058c.png" target="_blank" rel="noopener">image</a></p>
<p>[1] - 除非特别说明，AP 和 AR 一般是在多个 IoU(Intersection over Union) 值间取平均值. 具体地，采用了 10 个 IoU阈值 - <strong>0.50:0.05:0.95</strong>. 对比于传统的只计算单个 IoU 阈值(<strong>0.50</strong>)的指标(对应于这里的指标 APIoU=0.50)，这是一种突破. 对多个 IoU 阈值求平均，能够使得目标检测器具有更好的定位位置.</p>
<p>[2] - AP 是对所有类别的求平均值. 这在传统上被称为<strong>平均准确度(mAP, mean average precision)</strong>. 这里并未区分 AP 和 mAP(类似的，AR 和mAR)，假定从上下文中具有清晰的差异. 即：如，AP50=mAP50，AP75=mAP75，… 但，AP50 一定大于 AP75.</p>
<p>[3] - AP (所有 10 个 IoU 阈值和全部 80 个类别的平均值) 作为最终 COCO竞赛胜者的标准. 在考虑目标检测器再 COCO 上的性能时，这是单个最重要的评价度量指标.</p>
<p>[4] - COCO数据集中小目标物体数量比大目标物体更多. 具体地，标注的约有 41% 的目标物体是都很小的(small, 面积&lt; 32x32=1024)，约有 34% 的目标物体是中等的(medium, 1024=32x32 &lt; 面积 &lt; 96x96=9216)，约有 24% 的目标物体是大的(large, 面积 &gt; 96x96=9216). <strong>面积(area) 是指 segmentation mask 中像素的数量</strong>.</p>
<p>[5] - AR 是指每张图片中，在给定固定数量的检测结果中的最大召回(maximum recall)，在所有 IoUs 和全部类别上求平均值. AR 与 <strong><a href="https://arxiv.org/abs/1502.05082" target="_blank" rel="noopener">proposal evaluation</a></strong> 中所使用的相同，但这里 AR 是按类别计算的.</p>
<p>[6] - 所有的评测指标允许每张图片(在全部的类别中)最多 100 个 top-scoring 检测结果进行计算.</p>
<p>[7] - 边界框(bounding boxes)的检测和segmentation mask 的所有评测指标是一致的，除了 IoU 的计算. 边界框的 IoU 计算是关于 boxes的 ，而 segmentation mask 的 IoU 计算是关于 masks 的.</p>
<h2 id="2-评测指标实现-cocoeval"><a href="#2-评测指标实现-cocoeval" class="headerlink" title="2. 评测指标实现 - cocoeval"></a>2. 评测指标实现 - cocoeval</h2><blockquote>
<p><a href="https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocotools/cocoeval.py" target="_blank" rel="noopener">PythonAPI/pycocotools/cocoeval.py</a></p>
</blockquote>
<p>评测参数如 ：(括号里的默认值，一般不需要修改.)</p>
<p><a href="https://aiuai.cn/uploads/1905/1466342d14364de7.png" target="_blank" rel="noopener"><img src="https://aiuai.cn/uploads/1905/1466342d14364de7.png" alt="image"></a></p>
<p><a href="https://aiuai.cn/uploads/1905/1466342d14364de7.png" target="_blank" rel="noopener">image</a></p>
<p>通过调用 <code>evaluate()</code> 函数和 <code>accumulate()</code> 函数来运行，以计算得到衡量检测质量的两个数据结构(data structures).</p>
<p>这两个数据结构分别是 <code>evalImages</code> 和 <code>eval</code>，其分别每张图片的检测质量和整个数据集上的聚合检测质量.</p>
<p>数据结构 <code>evalImages</code> 共有 KxA 个元素，每个元素表示一个评测设置；而数据结构 <code>eval</code> 将这些信息组合为 precision 和 recall 数组. 具体如下：</p>
<p><a href="https://aiuai.cn/uploads/1905/b48d28af86a1b671.png" target="_blank" rel="noopener"><img src="https://aiuai.cn/uploads/1905/b48d28af86a1b671.png" alt="image"></a></p>
<p><a href="https://aiuai.cn/uploads/1905/b48d28af86a1b671.png" target="_blank" rel="noopener">image</a></p>
<p>Python 中的定义如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">'tsungyi'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> mask <span class="keyword">as</span> maskUtils</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COCOeval</span>:</span></span><br><span class="line">    <span class="comment"># COCO 数据集的检测评估接口.</span></span><br><span class="line">    <span class="comment"># The usage for CocoEval is as follows:</span></span><br><span class="line">    <span class="comment">#  cocoGt=..., cocoDt=...       # load dataset and results</span></span><br><span class="line">    <span class="comment">#  E = CocoEval(cocoGt,cocoDt); # initialize CocoEval object</span></span><br><span class="line">    <span class="comment">#  E.params.recThrs = ...;      # set parameters as desired</span></span><br><span class="line">    <span class="comment">#  E.evaluate();                # run per image evaluation</span></span><br><span class="line">    <span class="comment">#  E.accumulate();              # accumulate per image results</span></span><br><span class="line">    <span class="comment">#  E.summarize();               # display summary metrics of results</span></span><br><span class="line">    <span class="comment"># For example usage see evalDemo.m and http://mscoco.org/.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># The evaluation parameters are as follows (defaults in brackets):</span></span><br><span class="line">    <span class="comment">#  imgIds     - [all] N img ids to use for evaluation</span></span><br><span class="line">    <span class="comment">#  catIds     - [all] K cat ids to use for evaluation</span></span><br><span class="line">    <span class="comment">#  iouThrs    - [.5:.05:.95] T=10 IoU thresholds for evaluation</span></span><br><span class="line">    <span class="comment">#  recThrs    - [0:.01:1] R=101 recall thresholds for evaluation</span></span><br><span class="line">    <span class="comment">#  areaRng    - [...] A=4 object area ranges for evaluation</span></span><br><span class="line">    <span class="comment">#  maxDets    - [1 10 100] M=3 thresholds on max detections per image</span></span><br><span class="line">    <span class="comment">#  iouType    - ['segm'] set iouType to 'segm', 'bbox' or 'keypoints'</span></span><br><span class="line">    <span class="comment">#  iouType replaced the now DEPRECATED useSegm parameter.</span></span><br><span class="line">    <span class="comment">#  useCats    - [1] if true use category labels for evaluation</span></span><br><span class="line">    <span class="comment"># Note: if useCats=0 category labels are ignored as in proposal scoring.</span></span><br><span class="line">    <span class="comment"># Note: multiple areaRngs [Ax2] and maxDets [Mx1] can be specified.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># evaluate(): evaluates detections on every image and every category and</span></span><br><span class="line">    <span class="comment"># concats the results into the "evalImgs" with fields:</span></span><br><span class="line">    <span class="comment">#  dtIds      - [1xD] id for each of the D detections (dt)</span></span><br><span class="line">    <span class="comment">#  gtIds      - [1xG] id for each of the G ground truths (gt)</span></span><br><span class="line">    <span class="comment">#  dtMatches  - [TxD] matching gt id at each IoU or 0</span></span><br><span class="line">    <span class="comment">#  gtMatches  - [TxG] matching dt id at each IoU or 0</span></span><br><span class="line">    <span class="comment">#  dtScores   - [1xD] confidence of each dt</span></span><br><span class="line">    <span class="comment">#  gtIgnore   - [1xG] ignore flag for each gt</span></span><br><span class="line">    <span class="comment">#  dtIgnore   - [TxD] ignore flag for each dt at each IoU</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># accumulate(): accumulates the per-image, per-category evaluation</span></span><br><span class="line">    <span class="comment"># results in "evalImgs" into the dictionary "eval" with fields:</span></span><br><span class="line">    <span class="comment">#  params     - parameters used for evaluation</span></span><br><span class="line">    <span class="comment">#  date       - date evaluation was performed</span></span><br><span class="line">    <span class="comment">#  counts     - [T,R,K,A,M] parameter dimensions (see above)</span></span><br><span class="line">    <span class="comment">#  precision  - [TxRxKxAxM] precision for every evaluation setting</span></span><br><span class="line">    <span class="comment">#  recall     - [TxKxAxM] max recall for every evaluation setting</span></span><br><span class="line">    <span class="comment"># Note: precision and recall==-1 for settings with no gt objects.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># See also coco, mask, pycocoDemo, pycocoEvalDemo</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cocoGt=None, cocoDt=None, iouType=<span class="string">'segm'</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Initialize CocoEval using coco APIs for gt and dt</span></span><br><span class="line"><span class="string">        :param cocoGt: coco object with ground truth annotations</span></span><br><span class="line"><span class="string">        :param cocoDt: coco object with detection results</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> iouType:</span><br><span class="line">            print(<span class="string">'iouType not specified. use default iouType segm'</span>)</span><br><span class="line">        self.cocoGt   = cocoGt              <span class="comment"># ground truth COCO API</span></span><br><span class="line">        self.cocoDt   = cocoDt              <span class="comment"># detections COCO API</span></span><br><span class="line">        self.params   = &#123;&#125;                  <span class="comment"># evaluation parameters</span></span><br><span class="line">        self.evalImgs = defaultdict(list)   <span class="comment"># per-image per-category evaluation results [KxAxI] elements</span></span><br><span class="line">        self.eval     = &#123;&#125;                  <span class="comment"># accumulated evaluation results</span></span><br><span class="line">        self._gts = defaultdict(list)       <span class="comment"># gt for evaluation</span></span><br><span class="line">        self._dts = defaultdict(list)       <span class="comment"># dt for evaluation</span></span><br><span class="line">        self.params = Params(iouType=iouType) <span class="comment"># parameters</span></span><br><span class="line">        self._paramsEval = &#123;&#125;               <span class="comment"># parameters for evaluation</span></span><br><span class="line">        self.stats = []                     <span class="comment"># result summarization</span></span><br><span class="line">        self.ious = &#123;&#125;                      <span class="comment"># ious between all gts and dts</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cocoGt <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.params.imgIds = sorted(cocoGt.getImgIds())</span><br><span class="line">            self.params.catIds = sorted(cocoGt.getCatIds())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prepare</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Prepare ._gts and ._dts for evaluation based on params</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_toMask</span><span class="params">(anns, coco)</span>:</span></span><br><span class="line">            <span class="comment"># modify ann['segmentation'] by reference</span></span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">                rle = coco.annToRLE(ann)</span><br><span class="line">                ann[<span class="string">'segmentation'</span>] = rle</span><br><span class="line">        p = self.params</span><br><span class="line">        <span class="keyword">if</span> p.useCats:</span><br><span class="line">            gts=self.cocoGt.loadAnns(self.cocoGt.getAnnIds(imgIds=p.imgIds, catIds=p.catIds))</span><br><span class="line">            dts=self.cocoDt.loadAnns(self.cocoDt.getAnnIds(imgIds=p.imgIds, catIds=p.catIds))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gts=self.cocoGt.loadAnns(self.cocoGt.getAnnIds(imgIds=p.imgIds))</span><br><span class="line">            dts=self.cocoDt.loadAnns(self.cocoDt.getAnnIds(imgIds=p.imgIds))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># convert ground truth to mask if iouType == 'segm'</span></span><br><span class="line">        <span class="keyword">if</span> p.iouType == <span class="string">'segm'</span>:</span><br><span class="line">            _toMask(gts, self.cocoGt)</span><br><span class="line">            _toMask(dts, self.cocoDt)</span><br><span class="line">        <span class="comment"># set ignore flag</span></span><br><span class="line">        <span class="keyword">for</span> gt <span class="keyword">in</span> gts:</span><br><span class="line">            gt[<span class="string">'ignore'</span>] = gt[<span class="string">'ignore'</span>] <span class="keyword">if</span> <span class="string">'ignore'</span> <span class="keyword">in</span> gt <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            gt[<span class="string">'ignore'</span>] = <span class="string">'iscrowd'</span> <span class="keyword">in</span> gt <span class="keyword">and</span> gt[<span class="string">'iscrowd'</span>]</span><br><span class="line">            <span class="keyword">if</span> p.iouType == <span class="string">'keypoints'</span>:</span><br><span class="line">                gt[<span class="string">'ignore'</span>] = (gt[<span class="string">'num_keypoints'</span>] == <span class="number">0</span>) <span class="keyword">or</span> gt[<span class="string">'ignore'</span>]</span><br><span class="line">        self._gts = defaultdict(list)       <span class="comment"># gt for evaluation</span></span><br><span class="line">        self._dts = defaultdict(list)       <span class="comment"># dt for evaluation</span></span><br><span class="line">        <span class="keyword">for</span> gt <span class="keyword">in</span> gts:</span><br><span class="line">            self._gts[gt[<span class="string">'image_id'</span>], gt[<span class="string">'category_id'</span>]].append(gt)</span><br><span class="line">        <span class="keyword">for</span> dt <span class="keyword">in</span> dts:</span><br><span class="line">            self._dts[dt[<span class="string">'image_id'</span>], dt[<span class="string">'category_id'</span>]].append(dt)</span><br><span class="line">        self.evalImgs = defaultdict(list)   <span class="comment"># per-image per-category evaluation results</span></span><br><span class="line">        self.eval     = &#123;&#125;                  <span class="comment"># accumulated evaluation results</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Run per image evaluation on given images and store results (a list of dict) in self.evalImgs</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        tic = time.time()</span><br><span class="line">        print(<span class="string">'Running per image evaluation...'</span>)</span><br><span class="line">        p = self.params</span><br><span class="line">        <span class="comment"># add backward compatibility if useSegm is specified in params</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.useSegm <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p.iouType = <span class="string">'segm'</span> <span class="keyword">if</span> p.useSegm == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'bbox'</span></span><br><span class="line">            print(<span class="string">'useSegm (deprecated) is not None. Running &#123;&#125; evaluation'</span>.format(p.iouType))</span><br><span class="line">        print(<span class="string">'Evaluate annotation type *&#123;&#125;*'</span>.format(p.iouType))</span><br><span class="line">        p.imgIds = list(np.unique(p.imgIds))</span><br><span class="line">        <span class="keyword">if</span> p.useCats:</span><br><span class="line">            p.catIds = list(np.unique(p.catIds))</span><br><span class="line">        p.maxDets = sorted(p.maxDets)</span><br><span class="line">        self.params=p</span><br><span class="line"></span><br><span class="line">        self._prepare()</span><br><span class="line">        <span class="comment"># loop through images, area range, max detection number</span></span><br><span class="line">        catIds = p.catIds <span class="keyword">if</span> p.useCats <span class="keyword">else</span> [<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.iouType == <span class="string">'segm'</span> <span class="keyword">or</span> p.iouType == <span class="string">'bbox'</span>:</span><br><span class="line">            computeIoU = self.computeIoU</span><br><span class="line">        <span class="keyword">elif</span> p.iouType == <span class="string">'keypoints'</span>:</span><br><span class="line">            computeIoU = self.computeOks</span><br><span class="line">        self.ious = &#123;(imgId, catId): computeIoU(imgId, catId) \</span><br><span class="line">                        <span class="keyword">for</span> imgId <span class="keyword">in</span> p.imgIds</span><br><span class="line">                        <span class="keyword">for</span> catId <span class="keyword">in</span> catIds&#125;</span><br><span class="line"></span><br><span class="line">        evaluateImg = self.evaluateImg</span><br><span class="line">        maxDet = p.maxDets[<span class="number">-1</span>]</span><br><span class="line">        self.evalImgs = [evaluateImg(imgId, catId, areaRng, maxDet)</span><br><span class="line">                 <span class="keyword">for</span> catId <span class="keyword">in</span> catIds</span><br><span class="line">                 <span class="keyword">for</span> areaRng <span class="keyword">in</span> p.areaRng</span><br><span class="line">                 <span class="keyword">for</span> imgId <span class="keyword">in</span> p.imgIds</span><br><span class="line">             ]</span><br><span class="line">        self._paramsEval = copy.deepcopy(self.params)</span><br><span class="line">        toc = time.time()</span><br><span class="line">        print(<span class="string">'DONE (t=&#123;:0.2f&#125;s).'</span>.format(toc-tic))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeIoU</span><span class="params">(self, imgId, catId)</span>:</span></span><br><span class="line">        p = self.params</span><br><span class="line">        <span class="keyword">if</span> p.useCats:</span><br><span class="line">            gt = self._gts[imgId,catId]</span><br><span class="line">            dt = self._dts[imgId,catId]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gt = [_ <span class="keyword">for</span> cId <span class="keyword">in</span> p.catIds <span class="keyword">for</span> _ <span class="keyword">in</span> self._gts[imgId,cId]]</span><br><span class="line">            dt = [_ <span class="keyword">for</span> cId <span class="keyword">in</span> p.catIds <span class="keyword">for</span> _ <span class="keyword">in</span> self._dts[imgId,cId]]</span><br><span class="line">        <span class="keyword">if</span> len(gt) == <span class="number">0</span> <span class="keyword">and</span> len(dt) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        inds = np.argsort([-d[<span class="string">'score'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt], kind=<span class="string">'mergesort'</span>)</span><br><span class="line">        dt = [dt[i] <span class="keyword">for</span> i <span class="keyword">in</span> inds]</span><br><span class="line">        <span class="keyword">if</span> len(dt) &gt; p.maxDets[<span class="number">-1</span>]:</span><br><span class="line">            dt=dt[<span class="number">0</span>:p.maxDets[<span class="number">-1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.iouType == <span class="string">'segm'</span>:</span><br><span class="line">            g = [g[<span class="string">'segmentation'</span>] <span class="keyword">for</span> g <span class="keyword">in</span> gt]</span><br><span class="line">            d = [d[<span class="string">'segmentation'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt]</span><br><span class="line">        <span class="keyword">elif</span> p.iouType == <span class="string">'bbox'</span>:</span><br><span class="line">            g = [g[<span class="string">'bbox'</span>] <span class="keyword">for</span> g <span class="keyword">in</span> gt]</span><br><span class="line">            d = [d[<span class="string">'bbox'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'unknown iouType for iou computation'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># compute iou between each dt and gt region</span></span><br><span class="line">        iscrowd = [int(o[<span class="string">'iscrowd'</span>]) <span class="keyword">for</span> o <span class="keyword">in</span> gt]</span><br><span class="line">        ious = maskUtils.iou(d,g,iscrowd)</span><br><span class="line">        <span class="keyword">return</span> ious</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computeOks</span><span class="params">(self, imgId, catId)</span>:</span></span><br><span class="line">        p = self.params</span><br><span class="line">        <span class="comment"># dimention here should be Nxm</span></span><br><span class="line">        gts = self._gts[imgId, catId]</span><br><span class="line">        dts = self._dts[imgId, catId]</span><br><span class="line">        inds = np.argsort([-d[<span class="string">'score'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dts], kind=<span class="string">'mergesort'</span>)</span><br><span class="line">        dts = [dts[i] <span class="keyword">for</span> i <span class="keyword">in</span> inds]</span><br><span class="line">        <span class="keyword">if</span> len(dts) &gt; p.maxDets[<span class="number">-1</span>]:</span><br><span class="line">            dts = dts[<span class="number">0</span>:p.maxDets[<span class="number">-1</span>]]</span><br><span class="line">        <span class="comment"># if len(gts) == 0 and len(dts) == 0:</span></span><br><span class="line">        <span class="keyword">if</span> len(gts) == <span class="number">0</span> <span class="keyword">or</span> len(dts) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ious = np.zeros((len(dts), len(gts)))</span><br><span class="line">        sigmas = np.array([<span class="number">.26</span>, <span class="number">.25</span>, <span class="number">.25</span>, <span class="number">.35</span>, <span class="number">.35</span>, <span class="number">.79</span>, <span class="number">.79</span>, <span class="number">.72</span>, <span class="number">.72</span>, <span class="number">.62</span>,<span class="number">.62</span>, <span class="number">1.07</span>, <span class="number">1.07</span>, <span class="number">.87</span>, <span class="number">.87</span>, <span class="number">.89</span>, <span class="number">.89</span>])/<span class="number">10.0</span></span><br><span class="line">        vars = (sigmas * <span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">        k = len(sigmas)</span><br><span class="line">        <span class="comment"># compute oks between each detection and ground truth object</span></span><br><span class="line">        <span class="keyword">for</span> j, gt <span class="keyword">in</span> enumerate(gts):</span><br><span class="line">            <span class="comment"># create bounds for ignore regions(double the gt bbox)</span></span><br><span class="line">            g = np.array(gt[<span class="string">'keypoints'</span>])</span><br><span class="line">            xg = g[<span class="number">0</span>::<span class="number">3</span>]; yg = g[<span class="number">1</span>::<span class="number">3</span>]; vg = g[<span class="number">2</span>::<span class="number">3</span>]</span><br><span class="line">            k1 = np.count_nonzero(vg &gt; <span class="number">0</span>)</span><br><span class="line">            bb = gt[<span class="string">'bbox'</span>]</span><br><span class="line">            x0 = bb[<span class="number">0</span>] - bb[<span class="number">2</span>]; x1 = bb[<span class="number">0</span>] + bb[<span class="number">2</span>] * <span class="number">2</span></span><br><span class="line">            y0 = bb[<span class="number">1</span>] - bb[<span class="number">3</span>]; y1 = bb[<span class="number">1</span>] + bb[<span class="number">3</span>] * <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i, dt <span class="keyword">in</span> enumerate(dts):</span><br><span class="line">                d = np.array(dt[<span class="string">'keypoints'</span>])</span><br><span class="line">                xd = d[<span class="number">0</span>::<span class="number">3</span>]; yd = d[<span class="number">1</span>::<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">if</span> k1&gt;<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># measure the per-keypoint distance if keypoints visible</span></span><br><span class="line">                    dx = xd - xg</span><br><span class="line">                    dy = yd - yg</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># measure minimum distance to keypoints in (x0,y0) &amp; (x1,y1)</span></span><br><span class="line">                    z = np.zeros((k))</span><br><span class="line">                    dx = np.max((z, x0-xd),axis=<span class="number">0</span>)+np.max((z, xd-x1),axis=<span class="number">0</span>)</span><br><span class="line">                    dy = np.max((z, y0-yd),axis=<span class="number">0</span>)+np.max((z, yd-y1),axis=<span class="number">0</span>)</span><br><span class="line">                e = (dx**<span class="number">2</span> + dy**<span class="number">2</span>) / vars / (gt[<span class="string">'area'</span>]+np.spacing(<span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> k1 &gt; <span class="number">0</span>:</span><br><span class="line">                    e=e[vg &gt; <span class="number">0</span>]</span><br><span class="line">                ious[i, j] = np.sum(np.exp(-e)) / e.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ious</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluateImg</span><span class="params">(self, imgId, catId, aRng, maxDet)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        perform evaluation for single category and image</span></span><br><span class="line"><span class="string">        :return: dict (single image results)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        p = self.params</span><br><span class="line">        <span class="keyword">if</span> p.useCats:</span><br><span class="line">            gt = self._gts[imgId,catId]</span><br><span class="line">            dt = self._dts[imgId,catId]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gt = [_ <span class="keyword">for</span> cId <span class="keyword">in</span> p.catIds <span class="keyword">for</span> _ <span class="keyword">in</span> self._gts[imgId,cId]]</span><br><span class="line">            dt = [_ <span class="keyword">for</span> cId <span class="keyword">in</span> p.catIds <span class="keyword">for</span> _ <span class="keyword">in</span> self._dts[imgId,cId]]</span><br><span class="line">        <span class="keyword">if</span> len(gt) == <span class="number">0</span> <span class="keyword">and</span> len(dt) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> gt:</span><br><span class="line">            <span class="keyword">if</span> g[<span class="string">'ignore'</span>] <span class="keyword">or</span> (g[<span class="string">'area'</span>]&lt;aRng[<span class="number">0</span>] <span class="keyword">or</span> g[<span class="string">'area'</span>]&gt;aRng[<span class="number">1</span>]):</span><br><span class="line">                g[<span class="string">'_ignore'</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                g[<span class="string">'_ignore'</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># sort dt highest score first, sort gt ignore last</span></span><br><span class="line">        gtind = np.argsort([g[<span class="string">'_ignore'</span>] <span class="keyword">for</span> g <span class="keyword">in</span> gt], kind=<span class="string">'mergesort'</span>)</span><br><span class="line">        gt = [gt[i] <span class="keyword">for</span> i <span class="keyword">in</span> gtind]</span><br><span class="line">        dtind = np.argsort([-d[<span class="string">'score'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt], kind=<span class="string">'mergesort'</span>)</span><br><span class="line">        dt = [dt[i] <span class="keyword">for</span> i <span class="keyword">in</span> dtind[<span class="number">0</span>:maxDet]]</span><br><span class="line">        iscrowd = [int(o[<span class="string">'iscrowd'</span>]) <span class="keyword">for</span> o <span class="keyword">in</span> gt]</span><br><span class="line">        <span class="comment"># load computed ious</span></span><br><span class="line">        ious = self.ious[imgId, catId][:, gtind] <span class="keyword">if</span> len(self.ious[imgId, catId]) &gt; <span class="number">0</span> <span class="keyword">else</span> self.ious[imgId, catId]</span><br><span class="line"></span><br><span class="line">        T = len(p.iouThrs)</span><br><span class="line">        G = len(gt)</span><br><span class="line">        D = len(dt)</span><br><span class="line">        gtm  = np.zeros((T,G))</span><br><span class="line">        dtm  = np.zeros((T,D))</span><br><span class="line">        gtIg = np.array([g[<span class="string">'_ignore'</span>] <span class="keyword">for</span> g <span class="keyword">in</span> gt])</span><br><span class="line">        dtIg = np.zeros((T,D))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(ious)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> tind, t <span class="keyword">in</span> enumerate(p.iouThrs):</span><br><span class="line">                <span class="keyword">for</span> dind, d <span class="keyword">in</span> enumerate(dt):</span><br><span class="line">                    <span class="comment"># information about best match so far (m=-1 -&gt; unmatched)</span></span><br><span class="line">                    iou = min([t,<span class="number">1</span><span class="number">-1e-10</span>])</span><br><span class="line">                    m   = <span class="number">-1</span></span><br><span class="line">                    <span class="keyword">for</span> gind, g <span class="keyword">in</span> enumerate(gt):</span><br><span class="line">                        <span class="comment"># if this gt already matched, and not a crowd, continue</span></span><br><span class="line">                        <span class="keyword">if</span> gtm[tind,gind]&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> iscrowd[gind]:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># if dt matched to reg gt, and on ignore gt, stop</span></span><br><span class="line">                        <span class="keyword">if</span> m&gt;<span class="number">-1</span> <span class="keyword">and</span> gtIg[m]==<span class="number">0</span> <span class="keyword">and</span> gtIg[gind]==<span class="number">1</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="comment"># continue to next gt unless better match made</span></span><br><span class="line">                        <span class="keyword">if</span> ious[dind,gind] &lt; iou:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment"># if match successful and best so far, store appropriately</span></span><br><span class="line">                        iou=ious[dind,gind]</span><br><span class="line">                        m=gind</span><br><span class="line">                    <span class="comment"># if match made store id of match for both dt and gt</span></span><br><span class="line">                    <span class="keyword">if</span> m ==<span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    dtIg[tind,dind] = gtIg[m]</span><br><span class="line">                    dtm[tind,dind]  = gt[m][<span class="string">'id'</span>]</span><br><span class="line">                    gtm[tind,m]     = d[<span class="string">'id'</span>]</span><br><span class="line">        <span class="comment"># set unmatched detections outside of area range to ignore</span></span><br><span class="line">        a = np.array([d[<span class="string">'area'</span>]&lt;aRng[<span class="number">0</span>] <span class="keyword">or</span> d[<span class="string">'area'</span>]&gt;aRng[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt]).reshape((<span class="number">1</span>, len(dt)))</span><br><span class="line">        dtIg = np.logical_or(dtIg, np.logical_and(dtm==<span class="number">0</span>, np.repeat(a,T,<span class="number">0</span>)))</span><br><span class="line">        <span class="comment"># store results for given image and category</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="string">'image_id'</span>:     imgId,</span><br><span class="line">                <span class="string">'category_id'</span>:  catId,</span><br><span class="line">                <span class="string">'aRng'</span>:         aRng,</span><br><span class="line">                <span class="string">'maxDet'</span>:       maxDet,</span><br><span class="line">                <span class="string">'dtIds'</span>:        [d[<span class="string">'id'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt],</span><br><span class="line">                <span class="string">'gtIds'</span>:        [g[<span class="string">'id'</span>] <span class="keyword">for</span> g <span class="keyword">in</span> gt],</span><br><span class="line">                <span class="string">'dtMatches'</span>:    dtm,</span><br><span class="line">                <span class="string">'gtMatches'</span>:    gtm,</span><br><span class="line">                <span class="string">'dtScores'</span>:     [d[<span class="string">'score'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> dt],</span><br><span class="line">                <span class="string">'gtIgnore'</span>:     gtIg,</span><br><span class="line">                <span class="string">'dtIgnore'</span>:     dtIg,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(self, p = None)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Accumulate per image evaluation results and store the result in self.eval</span></span><br><span class="line"><span class="string">        :param p: input params for evaluation</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        print(<span class="string">'Accumulating evaluation results...'</span>)</span><br><span class="line">        tic = time.time()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.evalImgs:</span><br><span class="line">            print(<span class="string">'Please run evaluate() first'</span>)</span><br><span class="line">        <span class="comment"># allows input customized parameters</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            p = self.params</span><br><span class="line">        p.catIds = p.catIds <span class="keyword">if</span> p.useCats == <span class="number">1</span> <span class="keyword">else</span> [<span class="number">-1</span>]</span><br><span class="line">        T           = len(p.iouThrs)</span><br><span class="line">        R           = len(p.recThrs)</span><br><span class="line">        K           = len(p.catIds) <span class="keyword">if</span> p.useCats <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        A           = len(p.areaRng)</span><br><span class="line">        M           = len(p.maxDets)</span><br><span class="line">        precision   = -np.ones((T,R,K,A,M)) <span class="comment"># -1 for the precision of absent categories</span></span><br><span class="line">        recall      = -np.ones((T,K,A,M))</span><br><span class="line">        scores      = -np.ones((T,R,K,A,M))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create dictionary for future indexing</span></span><br><span class="line">        _pe = self._paramsEval</span><br><span class="line">        catIds = _pe.catIds <span class="keyword">if</span> _pe.useCats <span class="keyword">else</span> [<span class="number">-1</span>]</span><br><span class="line">        setK = set(catIds)</span><br><span class="line">        setA = set(map(tuple, _pe.areaRng))</span><br><span class="line">        setM = set(_pe.maxDets)</span><br><span class="line">        setI = set(_pe.imgIds)</span><br><span class="line">        <span class="comment"># get inds to evaluate</span></span><br><span class="line">        k_list = [n <span class="keyword">for</span> n, k <span class="keyword">in</span> enumerate(p.catIds)  <span class="keyword">if</span> k <span class="keyword">in</span> setK]</span><br><span class="line">        m_list = [m <span class="keyword">for</span> n, m <span class="keyword">in</span> enumerate(p.maxDets) <span class="keyword">if</span> m <span class="keyword">in</span> setM]</span><br><span class="line">        a_list = [n <span class="keyword">for</span> n, a <span class="keyword">in</span> enumerate(map(<span class="keyword">lambda</span> x: tuple(x), p.areaRng)) <span class="keyword">if</span> a <span class="keyword">in</span> setA]</span><br><span class="line">        i_list = [n <span class="keyword">for</span> n, i <span class="keyword">in</span> enumerate(p.imgIds)  <span class="keyword">if</span> i <span class="keyword">in</span> setI]</span><br><span class="line">        I0 = len(_pe.imgIds)</span><br><span class="line">        A0 = len(_pe.areaRng)</span><br><span class="line">        <span class="comment"># retrieve E at each category, area range, and max number of detections</span></span><br><span class="line">        <span class="keyword">for</span> k, k0 <span class="keyword">in</span> enumerate(k_list):</span><br><span class="line">            Nk = k0*A0*I0</span><br><span class="line">            <span class="keyword">for</span> a, a0 <span class="keyword">in</span> enumerate(a_list):</span><br><span class="line">                Na = a0*I0</span><br><span class="line">                <span class="keyword">for</span> m, maxDet <span class="keyword">in</span> enumerate(m_list):</span><br><span class="line">                    E = [self.evalImgs[Nk + Na + i] <span class="keyword">for</span> i <span class="keyword">in</span> i_list]</span><br><span class="line">                    E = [e <span class="keyword">for</span> e <span class="keyword">in</span> E <span class="keyword">if</span> <span class="keyword">not</span> e <span class="keyword">is</span> <span class="literal">None</span>]</span><br><span class="line">                    <span class="keyword">if</span> len(E) == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    dtScores = np.concatenate([e[<span class="string">'dtScores'</span>][<span class="number">0</span>:maxDet] <span class="keyword">for</span> e <span class="keyword">in</span> E])</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># different sorting method generates slightly different results.</span></span><br><span class="line">                    <span class="comment"># mergesort is used to be consistent as Matlab implementation.</span></span><br><span class="line">                    inds = np.argsort(-dtScores, kind=<span class="string">'mergesort'</span>)</span><br><span class="line">                    dtScoresSorted = dtScores[inds]</span><br><span class="line"></span><br><span class="line">                    dtm  = np.concatenate([e[<span class="string">'dtMatches'</span>][:,<span class="number">0</span>:maxDet] <span class="keyword">for</span> e <span class="keyword">in</span> E], axis=<span class="number">1</span>)[:,inds]</span><br><span class="line">                    dtIg = np.concatenate([e[<span class="string">'dtIgnore'</span>][:,<span class="number">0</span>:maxDet]  <span class="keyword">for</span> e <span class="keyword">in</span> E], axis=<span class="number">1</span>)[:,inds]</span><br><span class="line">                    gtIg = np.concatenate([e[<span class="string">'gtIgnore'</span>] <span class="keyword">for</span> e <span class="keyword">in</span> E])</span><br><span class="line">                    npig = np.count_nonzero(gtIg==<span class="number">0</span> )</span><br><span class="line">                    <span class="keyword">if</span> npig == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    tps = np.logical_and(               dtm,  np.logical_not(dtIg) )</span><br><span class="line">                    fps = np.logical_and(np.logical_not(dtm), np.logical_not(dtIg) )</span><br><span class="line"></span><br><span class="line">                    tp_sum = np.cumsum(tps, axis=<span class="number">1</span>).astype(dtype=np.float)</span><br><span class="line">                    fp_sum = np.cumsum(fps, axis=<span class="number">1</span>).astype(dtype=np.float)</span><br><span class="line">                    <span class="keyword">for</span> t, (tp, fp) <span class="keyword">in</span> enumerate(zip(tp_sum, fp_sum)):</span><br><span class="line">                        tp = np.array(tp)</span><br><span class="line">                        fp = np.array(fp)</span><br><span class="line">                        nd = len(tp)</span><br><span class="line">                        rc = tp / npig</span><br><span class="line">                        pr = tp / (fp+tp+np.spacing(<span class="number">1</span>))</span><br><span class="line">                        q  = np.zeros((R,))</span><br><span class="line">                        ss = np.zeros((R,))</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> nd:</span><br><span class="line">                            recall[t,k,a,m] = rc[<span class="number">-1</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            recall[t,k,a,m] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># numpy is slow without cython optimization for accessing elements</span></span><br><span class="line">                        <span class="comment"># use python array gets significant speed improvement</span></span><br><span class="line">                        pr = pr.tolist(); q = q.tolist()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(nd<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                            <span class="keyword">if</span> pr[i] &gt; pr[i<span class="number">-1</span>]:</span><br><span class="line">                                pr[i<span class="number">-1</span>] = pr[i]</span><br><span class="line"></span><br><span class="line">                        inds = np.searchsorted(rc, p.recThrs, side=<span class="string">'left'</span>)</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            <span class="keyword">for</span> ri, pi <span class="keyword">in</span> enumerate(inds):</span><br><span class="line">                                q[ri] = pr[pi]</span><br><span class="line">                                ss[ri] = dtScoresSorted[pi]</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                        precision[t,:,k,a,m] = np.array(q)</span><br><span class="line">                        scores[t,:,k,a,m] = np.array(ss)</span><br><span class="line">        self.eval = &#123;</span><br><span class="line">            <span class="string">'params'</span>: p,</span><br><span class="line">            <span class="string">'counts'</span>: [T, R, K, A, M],</span><br><span class="line">            <span class="string">'date'</span>: datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>),</span><br><span class="line">            <span class="string">'precision'</span>: precision,</span><br><span class="line">            <span class="string">'recall'</span>:   recall,</span><br><span class="line">            <span class="string">'scores'</span>: scores,</span><br><span class="line">        &#125;</span><br><span class="line">        toc = time.time()</span><br><span class="line">        print(<span class="string">'DONE (t=&#123;:0.2f&#125;s).'</span>.format( toc-tic))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summarize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Compute and display summary metrics for evaluation results.</span></span><br><span class="line"><span class="string">        Note this functin can *only* be applied on the default parameter setting</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_summarize</span><span class="params">( ap=<span class="number">1</span>, iouThr=None, areaRng=<span class="string">'all'</span>, maxDets=<span class="number">100</span> )</span>:</span></span><br><span class="line">            p = self.params</span><br><span class="line">            iStr = <span class="string">' &#123;:&lt;18&#125; &#123;&#125; @[ IoU=&#123;:&lt;9&#125; | area=&#123;:&gt;6s&#125; | maxDets=&#123;:&gt;3d&#125; ] = &#123;:0.3f&#125;'</span></span><br><span class="line">            titleStr = <span class="string">'Average Precision'</span> <span class="keyword">if</span> ap == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'Average Recall'</span></span><br><span class="line">            typeStr = <span class="string">'(AP)'</span> <span class="keyword">if</span> ap==<span class="number">1</span> <span class="keyword">else</span> <span class="string">'(AR)'</span></span><br><span class="line">            iouStr = <span class="string">'&#123;:0.2f&#125;:&#123;:0.2f&#125;'</span>.format(p.iouThrs[<span class="number">0</span>], p.iouThrs[<span class="number">-1</span>]) \</span><br><span class="line">                <span class="keyword">if</span> iouThr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">'&#123;:0.2f&#125;'</span>.format(iouThr)</span><br><span class="line"></span><br><span class="line">            aind = [i <span class="keyword">for</span> i, aRng <span class="keyword">in</span> enumerate(p.areaRngLbl) <span class="keyword">if</span> aRng == areaRng]</span><br><span class="line">            mind = [i <span class="keyword">for</span> i, mDet <span class="keyword">in</span> enumerate(p.maxDets) <span class="keyword">if</span> mDet == maxDets]</span><br><span class="line">            <span class="keyword">if</span> ap == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># dimension of precision: [TxRxKxAxM]</span></span><br><span class="line">                s = self.eval[<span class="string">'precision'</span>]</span><br><span class="line">                <span class="comment"># IoU</span></span><br><span class="line">                <span class="keyword">if</span> iouThr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    t = np.where(iouThr == p.iouThrs)[<span class="number">0</span>]</span><br><span class="line">                    s = s[t]</span><br><span class="line">                s = s[:,:,:,aind,mind]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># dimension of recall: [TxKxAxM]</span></span><br><span class="line">                s = self.eval[<span class="string">'recall'</span>]</span><br><span class="line">                <span class="keyword">if</span> iouThr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    t = np.where(iouThr == p.iouThrs)[<span class="number">0</span>]</span><br><span class="line">                    s = s[t]</span><br><span class="line">                s = s[:,:,aind,mind]</span><br><span class="line">            <span class="keyword">if</span> len(s[s&gt;<span class="number">-1</span>])==<span class="number">0</span>:</span><br><span class="line">                mean_s = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mean_s = np.mean(s[s&gt;<span class="number">-1</span>])</span><br><span class="line">            print(iStr.format(titleStr, typeStr, iouStr, areaRng, maxDets, mean_s))</span><br><span class="line">            <span class="keyword">return</span> mean_s</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_summarizeDets</span><span class="params">()</span>:</span></span><br><span class="line">            stats = np.zeros((<span class="number">12</span>,))</span><br><span class="line">            stats[<span class="number">0</span>] = _summarize(<span class="number">1</span>)</span><br><span class="line">            stats[<span class="number">1</span>] = _summarize(<span class="number">1</span>, iouThr=<span class="number">.5</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">2</span>] = _summarize(<span class="number">1</span>, iouThr=<span class="number">.75</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">3</span>] = _summarize(<span class="number">1</span>, areaRng=<span class="string">'small'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">4</span>] = _summarize(<span class="number">1</span>, areaRng=<span class="string">'medium'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">5</span>] = _summarize(<span class="number">1</span>, areaRng=<span class="string">'large'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">6</span>] = _summarize(<span class="number">0</span>, maxDets=self.params.maxDets[<span class="number">0</span>])</span><br><span class="line">            stats[<span class="number">7</span>] = _summarize(<span class="number">0</span>, maxDets=self.params.maxDets[<span class="number">1</span>])</span><br><span class="line">            stats[<span class="number">8</span>] = _summarize(<span class="number">0</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">9</span>] = _summarize(<span class="number">0</span>, areaRng=<span class="string">'small'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">10</span>] = _summarize(<span class="number">0</span>, areaRng=<span class="string">'medium'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            stats[<span class="number">11</span>] = _summarize(<span class="number">0</span>, areaRng=<span class="string">'large'</span>, maxDets=self.params.maxDets[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">return</span> stats</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_summarizeKps</span><span class="params">()</span>:</span></span><br><span class="line">            stats = np.zeros((<span class="number">10</span>,))</span><br><span class="line">            stats[<span class="number">0</span>] = _summarize(<span class="number">1</span>, maxDets=<span class="number">20</span>)</span><br><span class="line">            stats[<span class="number">1</span>] = _summarize(<span class="number">1</span>, maxDets=<span class="number">20</span>, iouThr=<span class="number">.5</span>)</span><br><span class="line">            stats[<span class="number">2</span>] = _summarize(<span class="number">1</span>, maxDets=<span class="number">20</span>, iouThr=<span class="number">.75</span>)</span><br><span class="line">            stats[<span class="number">3</span>] = _summarize(<span class="number">1</span>, maxDets=<span class="number">20</span>, areaRng=<span class="string">'medium'</span>)</span><br><span class="line">            stats[<span class="number">4</span>] = _summarize(<span class="number">1</span>, maxDets=<span class="number">20</span>, areaRng=<span class="string">'large'</span>)</span><br><span class="line">            stats[<span class="number">5</span>] = _summarize(<span class="number">0</span>, maxDets=<span class="number">20</span>)</span><br><span class="line">            stats[<span class="number">6</span>] = _summarize(<span class="number">0</span>, maxDets=<span class="number">20</span>, iouThr=<span class="number">.5</span>)</span><br><span class="line">            stats[<span class="number">7</span>] = _summarize(<span class="number">0</span>, maxDets=<span class="number">20</span>, iouThr=<span class="number">.75</span>)</span><br><span class="line">            stats[<span class="number">8</span>] = _summarize(<span class="number">0</span>, maxDets=<span class="number">20</span>, areaRng=<span class="string">'medium'</span>)</span><br><span class="line">            stats[<span class="number">9</span>] = _summarize(<span class="number">0</span>, maxDets=<span class="number">20</span>, areaRng=<span class="string">'large'</span>)</span><br><span class="line">            <span class="keyword">return</span> stats</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.eval:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Please run accumulate() first'</span>)</span><br><span class="line">        iouType = self.params.iouType</span><br><span class="line">        <span class="keyword">if</span> iouType == <span class="string">'segm'</span> <span class="keyword">or</span> iouType == <span class="string">'bbox'</span>:</span><br><span class="line">            summarize = _summarizeDets</span><br><span class="line">        <span class="keyword">elif</span> iouType == <span class="string">'keypoints'</span>:</span><br><span class="line">            summarize = _summarizeKps</span><br><span class="line">        self.stats = summarize()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.summarize()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Params</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Params for coco evaluation api</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setDetParams</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.imgIds = []</span><br><span class="line">        self.catIds = []</span><br><span class="line">        <span class="comment"># np.arange causes trouble.  the data point on arange is slightly larger than the true value</span></span><br><span class="line">        self.iouThrs = np.linspace(<span class="number">.5</span>, <span class="number">0.95</span>, np.round((<span class="number">0.95</span> - <span class="number">.5</span>) / <span class="number">.05</span>) + <span class="number">1</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">        self.recThrs = np.linspace(<span class="number">.0</span>, <span class="number">1.00</span>, np.round((<span class="number">1.00</span> - <span class="number">.0</span>) / <span class="number">.01</span>) + <span class="number">1</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">        self.maxDets = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]</span><br><span class="line">        self.areaRng = [[<span class="number">0</span> ** <span class="number">2</span>, <span class="number">1e5</span> ** <span class="number">2</span>], [<span class="number">0</span> ** <span class="number">2</span>, <span class="number">32</span> ** <span class="number">2</span>], [<span class="number">32</span> ** <span class="number">2</span>, <span class="number">96</span> ** <span class="number">2</span>], [<span class="number">96</span> ** <span class="number">2</span>, <span class="number">1e5</span> ** <span class="number">2</span>]]</span><br><span class="line">        self.areaRngLbl = [<span class="string">'all'</span>, <span class="string">'small'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>]</span><br><span class="line">        self.useCats = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setKpParams</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.imgIds = []</span><br><span class="line">        self.catIds = []</span><br><span class="line">        <span class="comment"># np.arange causes trouble.  the data point on arange is slightly larger than the true value</span></span><br><span class="line">        self.iouThrs = np.linspace(<span class="number">.5</span>, <span class="number">0.95</span>, np.round((<span class="number">0.95</span> - <span class="number">.5</span>) / <span class="number">.05</span>) + <span class="number">1</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">        self.recThrs = np.linspace(<span class="number">.0</span>, <span class="number">1.00</span>, np.round((<span class="number">1.00</span> - <span class="number">.0</span>) / <span class="number">.01</span>) + <span class="number">1</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">        self.maxDets = [<span class="number">20</span>]</span><br><span class="line">        self.areaRng = [[<span class="number">0</span> ** <span class="number">2</span>, <span class="number">1e5</span> ** <span class="number">2</span>], [<span class="number">32</span> ** <span class="number">2</span>, <span class="number">96</span> ** <span class="number">2</span>], [<span class="number">96</span> ** <span class="number">2</span>, <span class="number">1e5</span> ** <span class="number">2</span>]]</span><br><span class="line">        self.areaRngLbl = [<span class="string">'all'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>]</span><br><span class="line">        self.useCats = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iouType=<span class="string">'segm'</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> iouType == <span class="string">'segm'</span> <span class="keyword">or</span> iouType == <span class="string">'bbox'</span>:</span><br><span class="line">            self.setDetParams()</span><br><span class="line">        <span class="keyword">elif</span> iouType == <span class="string">'keypoints'</span>:</span><br><span class="line">            self.setKpParams()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'iouType not supported'</span>)</span><br><span class="line">        self.iouType = iouType</span><br><span class="line">        <span class="comment"># useSegm is deprecated</span></span><br><span class="line">        self.useSegm = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="3-评测指标示例-pycocoEvalDemo"><a href="#3-评测指标示例-pycocoEvalDemo" class="headerlink" title="3. 评测指标示例 - pycocoEvalDemo"></a>3. 评测指标示例 - pycocoEvalDemo</h2><blockquote>
<p><a href="https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocoEvalDemo.ipynb" target="_blank" rel="noopener">PythonAPI/pycocoEvalDemo.ipynb</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="keyword">from</span> pycocotools.cocoeval <span class="keyword">import</span> COCOeval</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> skimage.io <span class="keyword">as</span> io</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line">pylab.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">annType = [<span class="string">'segm'</span>,<span class="string">'bbox'</span>,<span class="string">'keypoints'</span>]</span><br><span class="line">annType = annType[<span class="number">1</span>]      <span class="comment"># specify type here - bbox 类型</span></span><br><span class="line">prefix = <span class="string">'person_keypoints'</span> <span class="keyword">if</span> annType==<span class="string">'keypoints'</span> <span class="keyword">else</span> <span class="string">'instances'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Running demo for *%s* results.'</span>%(annType)</span><br><span class="line"></span><br><span class="line"><span class="comment">#initialize COCO ground truth api</span></span><br><span class="line">dataDir=<span class="string">'../'</span></span><br><span class="line">dataType=<span class="string">'val2014'</span></span><br><span class="line">annFile = <span class="string">'%s/annotations/%s_%s.json'</span>%(dataDir,prefix,dataType)</span><br><span class="line">cocoGt=COCO(annFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">#initialize COCO detections api</span></span><br><span class="line">resFile=<span class="string">'%s/results/%s_%s_fake%s100_results.json'</span></span><br><span class="line">resFile = resFile%(dataDir, prefix, dataType, annType)</span><br><span class="line">cocoDt=cocoGt.loadRes(resFile)</span><br><span class="line"></span><br><span class="line">imgIds=sorted(cocoGt.getImgIds())</span><br><span class="line">imgIds=imgIds[<span class="number">0</span>:<span class="number">100</span>]</span><br><span class="line">imgId = imgIds[np.random.randint(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># running evaluation</span></span><br><span class="line">cocoEval = COCOeval(cocoGt,cocoDt,annType)</span><br><span class="line">cocoEval.params.imgIds  = imgIds</span><br><span class="line">cocoEval.evaluate()</span><br><span class="line">cocoEval.accumulate()</span><br><span class="line">cocoEval.summarize()</span><br></pre></td></tr></table></figure>

<p>输出结果如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Running per image evaluation...      </span><br><span class="line">DONE (t=<span class="number">0.46</span>s).</span><br><span class="line">Accumulating evaluation results...   </span><br><span class="line">DONE (t=<span class="number">0.38</span>s).</span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=   all | maxDets=<span class="number">100</span> ] = <span class="number">0.505</span></span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.50</span>      | area=   all | maxDets=<span class="number">100</span> ] = <span class="number">0.697</span></span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.75</span>      | area=   all | maxDets=<span class="number">100</span> ] = <span class="number">0.573</span></span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area= small | maxDets=<span class="number">100</span> ] = <span class="number">0.586</span></span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=medium | maxDets=<span class="number">100</span> ] = <span class="number">0.519</span></span><br><span class="line"> Average Precision  (AP) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area= large | maxDets=<span class="number">100</span> ] = <span class="number">0.501</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=   all | maxDets=  <span class="number">1</span> ] = <span class="number">0.387</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=   all | maxDets= <span class="number">10</span> ] = <span class="number">0.594</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=   all | maxDets=<span class="number">100</span> ] = <span class="number">0.595</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area= small | maxDets=<span class="number">100</span> ] = <span class="number">0.640</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area=medium | maxDets=<span class="number">100</span> ] = <span class="number">0.566</span></span><br><span class="line"> Average Recall     (AR) @[ IoU=<span class="number">0.50</span>:<span class="number">0.95</span> | area= large | maxDets=<span class="number">100</span> ] = <span class="number">0.564</span></span><br></pre></td></tr></table></figure>

<h2 id="4-COCO-类"><a href="#4-COCO-类" class="headerlink" title="4. COCO 类"></a>4. COCO 类</h2><blockquote>
<p><a href="https://github.com/cocodataset/cocoapi/blob/master/PythonAPI/pycocotools/coco.py" target="_blank" rel="noopener">PythonAPI/pycocotools/coco.py</a></p>
</blockquote>
<p>COCO 格式数据集的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">'tylin'</span></span><br><span class="line">__version__ = <span class="string">'2.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API用于将 COCO 标注数据集 annotations 直接加载到 Python 字典.</span></span><br><span class="line"><span class="comment"># 还提供了其它辅助函数.</span></span><br><span class="line"><span class="comment"># 该 API 同时支持 *instance* 和 *caption* 的标注数据.</span></span><br><span class="line"><span class="comment"># 但，并未定义 *caption* 的全部函数(如，categories 暂未定义).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API 中包含的函数如下：</span></span><br><span class="line"><span class="comment"># 其中，"ann"=annotation, "cat"=category, and "img"=image.</span></span><br><span class="line"><span class="comment">#  COCO       - COCO api class that loads COCO annotation file and prepare data structures.</span></span><br><span class="line"><span class="comment">#  decodeMask - Decode binary mask M encoded via run-length encoding.</span></span><br><span class="line"><span class="comment">#  encodeMask - Encode binary mask M using run-length encoding.</span></span><br><span class="line"><span class="comment">#  getAnnIds  - Get ann ids that satisfy given filter conditions.</span></span><br><span class="line"><span class="comment">#  getCatIds  - Get cat ids that satisfy given filter conditions.</span></span><br><span class="line"><span class="comment">#  getImgIds  - Get img ids that satisfy given filter conditions.</span></span><br><span class="line"><span class="comment">#  loadAnns   - Load anns with the specified ids.</span></span><br><span class="line"><span class="comment">#  loadCats   - Load cats with the specified ids.</span></span><br><span class="line"><span class="comment">#  loadImgs   - Load imgs with the specified ids.</span></span><br><span class="line"><span class="comment">#  annToMask  - Convert segmentation in an annotation to binary mask.</span></span><br><span class="line"><span class="comment">#  showAnns   - Display the specified annotations.</span></span><br><span class="line"><span class="comment">#  loadRes    - Load algorithm results and create API for accessing them.</span></span><br><span class="line"><span class="comment">#  download   - Download COCO images from mscoco.org server.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> PatchCollection</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Polygon</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> mask <span class="keyword">as</span> maskUtils</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">PYTHON_VERSION = sys.version_info[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> PYTHON_VERSION == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">elif</span> PYTHON_VERSION == <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_isArrayLike</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hasattr(obj, <span class="string">'__iter__'</span>) <span class="keyword">and</span> hasattr(obj, <span class="string">'__len__'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COCO</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, annotation_file=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Constructor of Microsoft COCO helper class for reading and visualizing annotations.</span></span><br><span class="line"><span class="string">        :param annotation_file (str): location of annotation file</span></span><br><span class="line"><span class="string">        :param image_folder (str): location to the folder that hosts images.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># load dataset</span></span><br><span class="line">        self.dataset,self.anns,self.cats,self.imgs = dict(),dict(),dict(),dict()</span><br><span class="line">        self.imgToAnns, self.catToImgs = defaultdict(list), defaultdict(list)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> annotation_file == <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">'loading annotations into memory...'</span>)</span><br><span class="line">            tic = time.time()</span><br><span class="line">            dataset = json.load(open(annotation_file, <span class="string">'r'</span>))</span><br><span class="line">            <span class="keyword">assert</span> type(dataset)==dict, <span class="string">'annotation file format &#123;&#125; not supported'</span>.format(type(dataset))</span><br><span class="line">            print(<span class="string">'Done (t=&#123;:0.2f&#125;s)'</span>.format(time.time()- tic))</span><br><span class="line">            self.dataset = dataset</span><br><span class="line">            self.createIndex()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createIndex</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># create index</span></span><br><span class="line">        print(<span class="string">'creating index...'</span>)</span><br><span class="line">        anns, cats, imgs = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line">        imgToAnns,catToImgs = defaultdict(list),defaultdict(list)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'annotations'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> self.dataset[<span class="string">'annotations'</span>]:</span><br><span class="line">                imgToAnns[ann[<span class="string">'image_id'</span>]].append(ann)</span><br><span class="line">                anns[ann[<span class="string">'id'</span>]] = ann</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'images'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> img <span class="keyword">in</span> self.dataset[<span class="string">'images'</span>]:</span><br><span class="line">                imgs[img[<span class="string">'id'</span>]] = img</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'categories'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> cat <span class="keyword">in</span> self.dataset[<span class="string">'categories'</span>]:</span><br><span class="line">                cats[cat[<span class="string">'id'</span>]] = cat</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'annotations'</span> <span class="keyword">in</span> self.dataset <span class="keyword">and</span> <span class="string">'categories'</span> <span class="keyword">in</span> self.dataset:</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> self.dataset[<span class="string">'annotations'</span>]:</span><br><span class="line">                catToImgs[ann[<span class="string">'category_id'</span>]].append(ann[<span class="string">'image_id'</span>])</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'index created!'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create class members</span></span><br><span class="line">        self.anns = anns</span><br><span class="line">        self.imgToAnns = imgToAnns</span><br><span class="line">        self.catToImgs = catToImgs</span><br><span class="line">        self.imgs = imgs</span><br><span class="line">        self.cats = cats</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Print information about the annotation file.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.dataset[<span class="string">'info'</span>].items():</span><br><span class="line">            print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(key, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAnnIds</span><span class="params">(self, imgIds=[], catIds=[], areaRng=[], iscrowd=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get ann ids that satisfy given filter conditions. default skips that filter</span></span><br><span class="line"><span class="string">        :param imgIds  (int array)     : get anns for given imgs</span></span><br><span class="line"><span class="string">               catIds  (int array)     : get anns for given cats</span></span><br><span class="line"><span class="string">               areaRng (float array)   : get anns for given area range (e.g. [0 inf])</span></span><br><span class="line"><span class="string">               iscrowd (boolean)       : get anns for given crowd label (False or True)</span></span><br><span class="line"><span class="string">        :return: ids (int array)       : integer array of ann ids</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        imgIds = imgIds <span class="keyword">if</span> _isArrayLike(imgIds) <span class="keyword">else</span> [imgIds]</span><br><span class="line">        catIds = catIds <span class="keyword">if</span> _isArrayLike(catIds) <span class="keyword">else</span> [catIds]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(imgIds) == len(catIds) == len(areaRng) == <span class="number">0</span>:</span><br><span class="line">            anns = self.dataset[<span class="string">'annotations'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> len(imgIds) == <span class="number">0</span>:</span><br><span class="line">                lists = [self.imgToAnns[imgId] <span class="keyword">for</span> imgId <span class="keyword">in</span> imgIds <span class="keyword">if</span> imgId <span class="keyword">in</span> self.imgToAnns]</span><br><span class="line">                anns = list(itertools.chain.from_iterable(lists))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                anns = self.dataset[<span class="string">'annotations'</span>]</span><br><span class="line">            anns = anns <span class="keyword">if</span> len(catIds)  == <span class="number">0</span> <span class="keyword">else</span> [ann <span class="keyword">for</span> ann <span class="keyword">in</span> anns <span class="keyword">if</span> ann[<span class="string">'category_id'</span>] <span class="keyword">in</span> catIds]</span><br><span class="line">            anns = anns <span class="keyword">if</span> len(areaRng) == <span class="number">0</span> <span class="keyword">else</span> [ann <span class="keyword">for</span> ann <span class="keyword">in</span> anns <span class="keyword">if</span> ann[<span class="string">'area'</span>] &gt; areaRng[<span class="number">0</span>] <span class="keyword">and</span> ann[<span class="string">'area'</span>] &lt; areaRng[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> iscrowd == <span class="literal">None</span>:</span><br><span class="line">            ids = [ann[<span class="string">'id'</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns <span class="keyword">if</span> ann[<span class="string">'iscrowd'</span>] == iscrowd]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ids = [ann[<span class="string">'id'</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns]</span><br><span class="line">        <span class="keyword">return</span> ids</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCatIds</span><span class="params">(self, catNms=[], supNms=[], catIds=[])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        filtering parameters. default skips that filter.</span></span><br><span class="line"><span class="string">        :param catNms (str array)  : get cats for given cat names</span></span><br><span class="line"><span class="string">        :param supNms (str array)  : get cats for given supercategory names</span></span><br><span class="line"><span class="string">        :param catIds (int array)  : get cats for given cat ids</span></span><br><span class="line"><span class="string">        :return: ids (int array)   : integer array of cat ids</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        catNms = catNms <span class="keyword">if</span> _isArrayLike(catNms) <span class="keyword">else</span> [catNms]</span><br><span class="line">        supNms = supNms <span class="keyword">if</span> _isArrayLike(supNms) <span class="keyword">else</span> [supNms]</span><br><span class="line">        catIds = catIds <span class="keyword">if</span> _isArrayLike(catIds) <span class="keyword">else</span> [catIds]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(catNms) == len(supNms) == len(catIds) == <span class="number">0</span>:</span><br><span class="line">            cats = self.dataset[<span class="string">'categories'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cats = self.dataset[<span class="string">'categories'</span>]</span><br><span class="line">            cats = cats <span class="keyword">if</span> len(catNms) == <span class="number">0</span> <span class="keyword">else</span> [cat <span class="keyword">for</span> cat <span class="keyword">in</span> cats <span class="keyword">if</span> cat[<span class="string">'name'</span>]          <span class="keyword">in</span> catNms]</span><br><span class="line">            cats = cats <span class="keyword">if</span> len(supNms) == <span class="number">0</span> <span class="keyword">else</span> [cat <span class="keyword">for</span> cat <span class="keyword">in</span> cats <span class="keyword">if</span> cat[<span class="string">'supercategory'</span>] <span class="keyword">in</span> supNms]</span><br><span class="line">            cats = cats <span class="keyword">if</span> len(catIds) == <span class="number">0</span> <span class="keyword">else</span> [cat <span class="keyword">for</span> cat <span class="keyword">in</span> cats <span class="keyword">if</span> cat[<span class="string">'id'</span>]            <span class="keyword">in</span> catIds]</span><br><span class="line">        ids = [cat[<span class="string">'id'</span>] <span class="keyword">for</span> cat <span class="keyword">in</span> cats]</span><br><span class="line">        <span class="keyword">return</span> ids</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImgIds</span><span class="params">(self, imgIds=[], catIds=[])</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Get img ids that satisfy given filter conditions.</span></span><br><span class="line"><span class="string">        :param imgIds (int array) : get imgs for given ids</span></span><br><span class="line"><span class="string">        :param catIds (int array) : get imgs with all given cats</span></span><br><span class="line"><span class="string">        :return: ids (int array)  : integer array of img ids</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        imgIds = imgIds <span class="keyword">if</span> _isArrayLike(imgIds) <span class="keyword">else</span> [imgIds]</span><br><span class="line">        catIds = catIds <span class="keyword">if</span> _isArrayLike(catIds) <span class="keyword">else</span> [catIds]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(imgIds) == len(catIds) == <span class="number">0</span>:</span><br><span class="line">            ids = self.imgs.keys()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ids = set(imgIds)</span><br><span class="line">            <span class="keyword">for</span> i, catId <span class="keyword">in</span> enumerate(catIds):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> len(ids) == <span class="number">0</span>:</span><br><span class="line">                    ids = set(self.catToImgs[catId])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ids &amp;= set(self.catToImgs[catId])</span><br><span class="line">        <span class="keyword">return</span> list(ids)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadAnns</span><span class="params">(self, ids=[])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load anns with the specified ids.</span></span><br><span class="line"><span class="string">        :param ids (int array)       : integer ids specifying anns</span></span><br><span class="line"><span class="string">        :return: anns (object array) : loaded ann objects</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> _isArrayLike(ids):</span><br><span class="line">            <span class="keyword">return</span> [self.anns[id] <span class="keyword">for</span> id <span class="keyword">in</span> ids]</span><br><span class="line">        <span class="keyword">elif</span> type(ids) == int:</span><br><span class="line">            <span class="keyword">return</span> [self.anns[ids]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadCats</span><span class="params">(self, ids=[])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load cats with the specified ids.</span></span><br><span class="line"><span class="string">        :param ids (int array)       : integer ids specifying cats</span></span><br><span class="line"><span class="string">        :return: cats (object array) : loaded cat objects</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> _isArrayLike(ids):</span><br><span class="line">            <span class="keyword">return</span> [self.cats[id] <span class="keyword">for</span> id <span class="keyword">in</span> ids]</span><br><span class="line">        <span class="keyword">elif</span> type(ids) == int:</span><br><span class="line">            <span class="keyword">return</span> [self.cats[ids]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadImgs</span><span class="params">(self, ids=[])</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load anns with the specified ids.</span></span><br><span class="line"><span class="string">        :param ids (int array)       : integer ids specifying img</span></span><br><span class="line"><span class="string">        :return: imgs (object array) : loaded img objects</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> _isArrayLike(ids):</span><br><span class="line">            <span class="keyword">return</span> [self.imgs[id] <span class="keyword">for</span> id <span class="keyword">in</span> ids]</span><br><span class="line">        <span class="keyword">elif</span> type(ids) == int:</span><br><span class="line">            <span class="keyword">return</span> [self.imgs[ids]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showAnns</span><span class="params">(self, anns)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Display the specified annotations.</span></span><br><span class="line"><span class="string">        :param anns (array of object): annotations to display</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(anns) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'segmentation'</span> <span class="keyword">in</span> anns[<span class="number">0</span>] <span class="keyword">or</span> <span class="string">'keypoints'</span> <span class="keyword">in</span> anns[<span class="number">0</span>]:</span><br><span class="line">            datasetType = <span class="string">'instances'</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'caption'</span> <span class="keyword">in</span> anns[<span class="number">0</span>]:</span><br><span class="line">            datasetType = <span class="string">'captions'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'datasetType not supported'</span>)</span><br><span class="line">        <span class="keyword">if</span> datasetType == <span class="string">'instances'</span>:</span><br><span class="line">            ax = plt.gca()</span><br><span class="line">            ax.set_autoscale_on(<span class="literal">False</span>)</span><br><span class="line">            polygons = []</span><br><span class="line">            color = []</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">                c = (np.random.random((<span class="number">1</span>, <span class="number">3</span>))*<span class="number">0.6</span>+<span class="number">0.4</span>).tolist()[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'segmentation'</span> <span class="keyword">in</span> ann:</span><br><span class="line">                    <span class="keyword">if</span> type(ann[<span class="string">'segmentation'</span>]) == list:</span><br><span class="line">                        <span class="comment"># polygon</span></span><br><span class="line">                        <span class="keyword">for</span> seg <span class="keyword">in</span> ann[<span class="string">'segmentation'</span>]:</span><br><span class="line">                            poly = np.array(seg).reshape((int(len(seg)/<span class="number">2</span>), <span class="number">2</span>))</span><br><span class="line">                            polygons.append(Polygon(poly))</span><br><span class="line">                            color.append(c)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># mask</span></span><br><span class="line">                        t = self.imgs[ann[<span class="string">'image_id'</span>]]</span><br><span class="line">                        <span class="keyword">if</span> type(ann[<span class="string">'segmentation'</span>][<span class="string">'counts'</span>]) == list:</span><br><span class="line">                            rle = maskUtils.frPyObjects([ann[<span class="string">'segmentation'</span>]], t[<span class="string">'height'</span>], t[<span class="string">'width'</span>])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            rle = [ann[<span class="string">'segmentation'</span>]]</span><br><span class="line">                        m = maskUtils.decode(rle)</span><br><span class="line">                        img = np.ones( (m.shape[<span class="number">0</span>], m.shape[<span class="number">1</span>], <span class="number">3</span>) )</span><br><span class="line">                        <span class="keyword">if</span> ann[<span class="string">'iscrowd'</span>] == <span class="number">1</span>:</span><br><span class="line">                            color_mask = np.array([<span class="number">2.0</span>,<span class="number">166.0</span>,<span class="number">101.0</span>])/<span class="number">255</span></span><br><span class="line">                        <span class="keyword">if</span> ann[<span class="string">'iscrowd'</span>] == <span class="number">0</span>:</span><br><span class="line">                            color_mask = np.random.random((<span class="number">1</span>, <span class="number">3</span>)).tolist()[<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                            img[:,:,i] = color_mask[i]</span><br><span class="line">                        ax.imshow(np.dstack( (img, m*<span class="number">0.5</span>) ))</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'keypoints'</span> <span class="keyword">in</span> ann <span class="keyword">and</span> type(ann[<span class="string">'keypoints'</span>]) == list:</span><br><span class="line">                    <span class="comment"># turn skeleton into zero-based index</span></span><br><span class="line">                    sks = np.array(self.loadCats(ann[<span class="string">'category_id'</span>])[<span class="number">0</span>][<span class="string">'skeleton'</span>])<span class="number">-1</span></span><br><span class="line">                    kp = np.array(ann[<span class="string">'keypoints'</span>])</span><br><span class="line">                    x = kp[<span class="number">0</span>::<span class="number">3</span>]</span><br><span class="line">                    y = kp[<span class="number">1</span>::<span class="number">3</span>]</span><br><span class="line">                    v = kp[<span class="number">2</span>::<span class="number">3</span>]</span><br><span class="line">                    <span class="keyword">for</span> sk <span class="keyword">in</span> sks:</span><br><span class="line">                        <span class="keyword">if</span> np.all(v[sk]&gt;<span class="number">0</span>):</span><br><span class="line">                            plt.plot(x[sk],y[sk], linewidth=<span class="number">3</span>, color=c)</span><br><span class="line">                    plt.plot(x[v&gt;<span class="number">0</span>], y[v&gt;<span class="number">0</span>],<span class="string">'o'</span>,markersize=<span class="number">8</span>, markerfacecolor=c, markeredgecolor=<span class="string">'k'</span>,markeredgewidth=<span class="number">2</span>)</span><br><span class="line">                    plt.plot(x[v&gt;<span class="number">1</span>], y[v&gt;<span class="number">1</span>],<span class="string">'o'</span>,markersize=<span class="number">8</span>, markerfacecolor=c, markeredgecolor=c, markeredgewidth=<span class="number">2</span>)</span><br><span class="line">            p = PatchCollection(polygons, facecolor=color, linewidths=<span class="number">0</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line">            ax.add_collection(p)</span><br><span class="line">            p = PatchCollection(polygons, facecolor=<span class="string">'none'</span>, edgecolors=color, linewidths=<span class="number">2</span>)</span><br><span class="line">            ax.add_collection(p)</span><br><span class="line">        <span class="keyword">elif</span> datasetType == <span class="string">'captions'</span>:</span><br><span class="line">            <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">                print(ann[<span class="string">'caption'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadRes</span><span class="params">(self, resFile)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Load result file and return a result api object.</span></span><br><span class="line"><span class="string">        :param   resFile (str)     : file name of result file</span></span><br><span class="line"><span class="string">        :return: res (obj)         : result api object</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = COCO()</span><br><span class="line">        res.dataset[<span class="string">'images'</span>] = [img <span class="keyword">for</span> img <span class="keyword">in</span> self.dataset[<span class="string">'images'</span>]]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Loading and preparing results...'</span>)</span><br><span class="line">        tic = time.time()</span><br><span class="line">        <span class="keyword">if</span> type(resFile) == str <span class="keyword">or</span> type(resFile) == unicode:</span><br><span class="line">            anns = json.load(open(resFile))</span><br><span class="line">        <span class="keyword">elif</span> type(resFile) == np.ndarray:</span><br><span class="line">            anns = self.loadNumpyAnnotations(resFile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            anns = resFile</span><br><span class="line">        <span class="keyword">assert</span> type(anns) == list, <span class="string">'results in not an array of objects'</span></span><br><span class="line">        annsImgIds = [ann[<span class="string">'image_id'</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns]</span><br><span class="line">        <span class="keyword">assert</span> set(annsImgIds) == (set(annsImgIds) &amp; set(self.getImgIds())), \</span><br><span class="line">               <span class="string">'Results do not correspond to current coco set'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'caption'</span> <span class="keyword">in</span> anns[<span class="number">0</span>]:</span><br><span class="line">            imgIds = set([img[<span class="string">'id'</span>] <span class="keyword">for</span> img <span class="keyword">in</span> res.dataset[<span class="string">'images'</span>]]) &amp; set([ann[<span class="string">'image_id'</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns])</span><br><span class="line">            res.dataset[<span class="string">'images'</span>] = [img <span class="keyword">for</span> img <span class="keyword">in</span> res.dataset[<span class="string">'images'</span>] <span class="keyword">if</span> img[<span class="string">'id'</span>] <span class="keyword">in</span> imgIds]</span><br><span class="line">            <span class="keyword">for</span> id, ann <span class="keyword">in</span> enumerate(anns):</span><br><span class="line">                ann[<span class="string">'id'</span>] = id+<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'bbox'</span> <span class="keyword">in</span> anns[<span class="number">0</span>] <span class="keyword">and</span> <span class="keyword">not</span> anns[<span class="number">0</span>][<span class="string">'bbox'</span>] == []:</span><br><span class="line">            res.dataset[<span class="string">'categories'</span>] = copy.deepcopy(self.dataset[<span class="string">'categories'</span>])</span><br><span class="line">            <span class="keyword">for</span> id, ann <span class="keyword">in</span> enumerate(anns):</span><br><span class="line">                bb = ann[<span class="string">'bbox'</span>]</span><br><span class="line">                x1, x2, y1, y2 = [bb[<span class="number">0</span>], bb[<span class="number">0</span>]+bb[<span class="number">2</span>], bb[<span class="number">1</span>], bb[<span class="number">1</span>]+bb[<span class="number">3</span>]]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'segmentation'</span> <span class="keyword">in</span> ann:</span><br><span class="line">                    ann[<span class="string">'segmentation'</span>] = [[x1, y1, x1, y2, x2, y2, x2, y1]]</span><br><span class="line">                ann[<span class="string">'area'</span>] = bb[<span class="number">2</span>]*bb[<span class="number">3</span>]</span><br><span class="line">                ann[<span class="string">'id'</span>] = id+<span class="number">1</span></span><br><span class="line">                ann[<span class="string">'iscrowd'</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'segmentation'</span> <span class="keyword">in</span> anns[<span class="number">0</span>]:</span><br><span class="line">            res.dataset[<span class="string">'categories'</span>] = copy.deepcopy(self.dataset[<span class="string">'categories'</span>])</span><br><span class="line">            <span class="keyword">for</span> id, ann <span class="keyword">in</span> enumerate(anns):</span><br><span class="line">                <span class="comment"># now only support compressed RLE format as segmentation results</span></span><br><span class="line">                ann[<span class="string">'area'</span>] = maskUtils.area(ann[<span class="string">'segmentation'</span>])</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'bbox'</span> <span class="keyword">in</span> ann:</span><br><span class="line">                    ann[<span class="string">'bbox'</span>] = maskUtils.toBbox(ann[<span class="string">'segmentation'</span>])</span><br><span class="line">                ann[<span class="string">'id'</span>] = id+<span class="number">1</span></span><br><span class="line">                ann[<span class="string">'iscrowd'</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'keypoints'</span> <span class="keyword">in</span> anns[<span class="number">0</span>]:</span><br><span class="line">            res.dataset[<span class="string">'categories'</span>] = copy.deepcopy(self.dataset[<span class="string">'categories'</span>])</span><br><span class="line">            <span class="keyword">for</span> id, ann <span class="keyword">in</span> enumerate(anns):</span><br><span class="line">                s = ann[<span class="string">'keypoints'</span>]</span><br><span class="line">                x = s[<span class="number">0</span>::<span class="number">3</span>]</span><br><span class="line">                y = s[<span class="number">1</span>::<span class="number">3</span>]</span><br><span class="line">                x0,x1,y0,y1 = np.min(x), np.max(x), np.min(y), np.max(y)</span><br><span class="line">                ann[<span class="string">'area'</span>] = (x1-x0)*(y1-y0)</span><br><span class="line">                ann[<span class="string">'id'</span>] = id + <span class="number">1</span></span><br><span class="line">                ann[<span class="string">'bbox'</span>] = [x0,y0,x1-x0,y1-y0]</span><br><span class="line">        print(<span class="string">'DONE (t=&#123;:0.2f&#125;s)'</span>.format(time.time()- tic))</span><br><span class="line"></span><br><span class="line">        res.dataset[<span class="string">'annotations'</span>] = anns</span><br><span class="line">        res.createIndex()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, tarDir = None, imgIds = [] )</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Download COCO images from mscoco.org server.</span></span><br><span class="line"><span class="string">        :param tarDir (str): COCO results directory name</span></span><br><span class="line"><span class="string">               imgIds (list): images to be downloaded</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> tarDir <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">'Please specify target directory'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(imgIds) == <span class="number">0</span>:</span><br><span class="line">            imgs = self.imgs.values()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            imgs = self.loadImgs(imgIds)</span><br><span class="line">        N = len(imgs)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(tarDir):</span><br><span class="line">            os.makedirs(tarDir)</span><br><span class="line">        <span class="keyword">for</span> i, img <span class="keyword">in</span> enumerate(imgs):</span><br><span class="line">            tic = time.time()</span><br><span class="line">            fname = os.path.join(tarDir, img[<span class="string">'file_name'</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(fname):</span><br><span class="line">                urlretrieve(img[<span class="string">'coco_url'</span>], fname)</span><br><span class="line">            print(<span class="string">'downloaded &#123;&#125;/&#123;&#125; images (t=&#123;:0.1f&#125;s)'</span>.format(i, N, time.time()- tic))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadNumpyAnnotations</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Convert result data from a numpy array [Nx7] where each row contains &#123;imageID,x1,y1,w,h,score,class&#125;</span></span><br><span class="line"><span class="string">        :param  data (numpy.ndarray)</span></span><br><span class="line"><span class="string">        :return: annotations (python nested list)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">'Converting ndarray to lists...'</span>)</span><br><span class="line">        <span class="keyword">assert</span>(type(data) == np.ndarray)</span><br><span class="line">        print(data.shape)</span><br><span class="line">        <span class="keyword">assert</span>(data.shape[<span class="number">1</span>] == <span class="number">7</span>)</span><br><span class="line">        N = data.shape[<span class="number">0</span>]</span><br><span class="line">        ann = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">1000000</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(i,N))</span><br><span class="line">            ann += [&#123;</span><br><span class="line">                <span class="string">'image_id'</span>  : int(data[i, <span class="number">0</span>]),</span><br><span class="line">                <span class="string">'bbox'</span>  : [ data[i, <span class="number">1</span>], data[i, <span class="number">2</span>], data[i, <span class="number">3</span>], data[i, <span class="number">4</span>] ],</span><br><span class="line">                <span class="string">'score'</span> : data[i, <span class="number">5</span>],</span><br><span class="line">                <span class="string">'category_id'</span>: int(data[i, <span class="number">6</span>]),</span><br><span class="line">                &#125;]</span><br><span class="line">        <span class="keyword">return</span> ann</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">annToRLE</span><span class="params">(self, ann)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Convert annotation which can be polygons, uncompressed RLE to RLE.</span></span><br><span class="line"><span class="string">        :return: binary mask (numpy 2D array)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = self.imgs[ann[<span class="string">'image_id'</span>]]</span><br><span class="line">        h, w = t[<span class="string">'height'</span>], t[<span class="string">'width'</span>]</span><br><span class="line">        segm = ann[<span class="string">'segmentation'</span>]</span><br><span class="line">        <span class="keyword">if</span> type(segm) == list:</span><br><span class="line">            <span class="comment"># polygon -- a single object might consist of multiple parts</span></span><br><span class="line">            <span class="comment"># we merge all parts into one mask rle code</span></span><br><span class="line">            rles = maskUtils.frPyObjects(segm, h, w)</span><br><span class="line">            rle = maskUtils.merge(rles)</span><br><span class="line">        <span class="keyword">elif</span> type(segm[<span class="string">'counts'</span>]) == list:</span><br><span class="line">            <span class="comment"># uncompressed RLE</span></span><br><span class="line">            rle = maskUtils.frPyObjects(segm, h, w)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># rle</span></span><br><span class="line">            rle = ann[<span class="string">'segmentation'</span>]</span><br><span class="line">        <span class="keyword">return</span> rle</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">annToMask</span><span class="params">(self, ann)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Convert annotation which can be polygons, uncompressed RLE, or RLE to binary mask.</span></span><br><span class="line"><span class="string">        :return: binary mask (numpy 2D array)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rle = self.annToRLE(ann)</span><br><span class="line">        m = maskUtils.decode(rle)</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/08/18/%E5%9B%A0%E6%9E%9C%E5%8D%B7%E7%A7%AF%E5%92%8C%E6%89%A9%E5%B1%95%E5%8D%B7%E7%A7%AF/">因果卷积和扩展卷积</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/08/18/CasualCNN/">CasualCNN</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/08/18/%E6%97%B6%E9%97%B4%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C(TCN)%EF%BC%9A%E7%BB%93%E6%9E%84+pytorch%E4%BB%A3%E7%A0%81/">时间卷积网络(TCN)：结构+pytorch代码</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/07/19/%E3%80%90%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E3%80%91Stacked%20Hourglass%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">【人体姿态】Stacked Hourglass算法</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>